// === SCRIPT WIDE CONFIGURATION ===
// !! This is your Operations Spreadsheet ID !!
const OPERATIONS_SPREADSHEET_ID = "1SJvfFM8e205ZF8T772L2X-uqJIs9hcdATurXh1-7Cn8"; 
// The MusicianDatabaseID will be fetched from the Configuration sheet using getConfig()

// ==========================================================================
//  AUTOMATED TESTS
// ==========================================================================

// --- Testkonfiguration ---
// För Sequential Test
const TEST_PROJECT_ID_SEQ = "TEST_PROJ_SEQ_001"; 
const TEST_NEED_ID_SEQ = "TEST_NEED_SEQ_001";   
const TEST_MUSICIAN_ID_SEQ_A = "TEST_MUS_A_SEQ"; 
const TEST_MUSICIAN_ID_SEQ_B = "TEST_MUS_B_SEQ"; 
const TEST_RANKING_LIST_ID_SEQ = "RL_TEST_SEQ_VLN_TUTTI"; 

// För Parallel Test
const TEST_PROJECT_ID_PAR = "TEST_PROJ_PAR_001";
const TEST_NEED_ID_PAR = "TEST_NEED_PAR_001"; 
const TEST_MUSICIAN_ID_PAR_1 = "MUS-001"; 
const TEST_MUSICIAN_ID_PAR_2 = "MUS-005"; 
const TEST_MUSICIAN_ID_PAR_3 = "MUS-006"; 
const TEST_RANKING_LIST_ID_PAR = "RL_TEST_PAR_VLN_TUTTI";

// För FCFS Test
const TEST_PROJECT_ID_FCFS = "TEST_PROJ_FCFS_001";
const TEST_NEED_ID_FCFS_FILLED = "TEST_NEED_FCFS_FILL_001";
const TEST_NEED_ID_FCFS_INCOMPLETE = "TEST_NEED_FCFS_INC_001"; 
const TEST_RANKING_LIST_ID_FCFS_TRP = "RL_TEST_FCFS_TRP_POOL";
const TEST_MUSICIAN_ID_FCFS_X = "MUS_TRP_X_FCFS"; 
const TEST_MUSICIAN_ID_FCFS_Y = "MUS_TRP_Y_FCFS";
const TEST_MUSICIAN_ID_FCFS_Z = "MUS_TRP_Z_FCFS";

// För Reminder Test
const TEST_PROJECT_ID_REM = "TEST_PROJ_REM_001";
const TEST_NEED_ID_REM = "TEST_NEED_REM_001";
const TEST_MUSICIAN_ID_REM = "TEST_MUS_REM_001"; 
const TEST_RANKING_LIST_ID_REM = "RL_TEST_REM_GENERIC";


// --- Helper för Test Setup & Cleanup ---

function deleteRowByFieldValue(sheet, fieldName, valueToDelete, logPrefix = "TEST_CLEANUP") {
    if (!sheet) {
        return false;
    }
    const data = sheet.getDataRange().getValues();
    if (data.length === 0) return true; 

    const headers = data[0];
    const colIndex = headers.indexOf(fieldName);
    if (colIndex === -1) {
        return false; 
    }

    const newData = [headers]; 
    let deletedCount = 0;
    for (let i = 1; i < data.length; i++) {
        if (String(data[i][colIndex]) !== String(valueToDelete)) { 
            newData.push(data[i]);
        } else {
            deletedCount++;
        }
    }
    if (deletedCount > 0) {
        sheet.clearContents(); 
        if (newData.length > 0) { 
            sheet.getRange(1, 1, newData.length, headers.length).setValues(newData);
        } else { 
             if (headers && headers.length > 0) { 
                sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
             }
        }
        logEvent(logPrefix, "deleteRowByFieldValue", null, null, null, `Deleted ${deletedCount} rows from ${sheet.getName()} where ${fieldName} = ${valueToDelete}`);
    }
    return true;
}

function clearTestDataForScenario(projectID, needIDsArray) {
    logEvent("TEST_CLEANUP", "clearTestDataForScenario", projectID, needIDsArray.join(','), null, "Starting cleanup for scenario.");
    clearTestDataFromResponseTracking(needIDsArray, [projectID]);
    clearTestDataFromNeeds(needIDsArray, [projectID]);
    clearTestDataFromProjectInfo([projectID]); 
    clearTestDataFromEventLog([projectID]); 
    SpreadsheetApp.flush(); 
    logEvent("TEST_CLEANUP", "clearTestDataForScenario", projectID, needIDsArray.join(','), null, "Cleanup for scenario complete.");
}

function clearTestDataFromResponseTracking(needIDsArray, projectIDsArray = []) {
    const sheet = getSheet("ResponseTracking");
    if (!sheet) return;
    needIDsArray.forEach(needID => deleteRowByFieldValue(sheet, "NeedID", needID));
    projectIDsArray.forEach(projectID => deleteRowByFieldValue(sheet, "ProjectID", projectID));
}

function clearTestDataFromNeeds(needIDsArray, projectIDsArray = []) {
    const sheet = getSheet("Needs");
    if (!sheet) return;
    needIDsArray.forEach(needID => deleteRowByFieldValue(sheet, "NeedID", needID));
    projectIDsArray.forEach(projectID => deleteRowByFieldValue(sheet, "ProjectID", projectID));
}

function clearTestDataFromProjectInfo(projectIDsArray) {
    const sheet = getSheet("ProjectInfo");
    if (!sheet) return;
    projectIDsArray.forEach(projectID => deleteRowByFieldValue(sheet, "ProjectID", projectID));
}
function clearTestDataFromEventLog(projectIDsArray){
    const sheet = getSheet("EventLog");
    if(!sheet) return;
    projectIDsArray.forEach(projectID => deleteRowByFieldValue(sheet, "ProjectID", projectID, "TEST_EVENTLOG_CLEANUP"));
}


function setupTestData_SequentialScenario() {
  Logger.log("===== ENTERING setupTestData_SequentialScenario =====");
  try {
    clearTestDataForScenario(TEST_PROJECT_ID_SEQ, [TEST_NEED_ID_SEQ]);

    const piSheet = getSheet("ProjectInfo");
    if (!piSheet) throw new Error("ProjectInfo sheet not found in Sequential setup.");
    piSheet.appendRow([TEST_PROJECT_ID_SEQ, "Test Sequential Project", 25, "Sun 10-12", "Fri 19", 1, null, "Active", "Test Seq", new Date(), new Date()]);
    SpreadsheetApp.flush();
    Logger.log("Appended row to ProjectInfo for Sequential test.");

    const needsSheet = getSheet("Needs");
    if (!needsSheet) throw new Error("Needs sheet not found in Sequential setup.");
    needsSheet.appendRow([TEST_NEED_ID_SEQ, TEST_PROJECT_ID_SEQ, "INST-VLN", "IQ-VLN-TUTTI", 1, TEST_RANKING_LIST_ID_SEQ, "Sequential", null, null, "Active", "Test Seq Need", null, new Date(), new Date()]); // Added CreatedDate, LastModified
    SpreadsheetApp.flush();
    Logger.log("Appended row to Needs for Sequential test.");
    
    logEvent("TEST_SETUP", "setupTestData_SequentialScenario", TEST_PROJECT_ID_SEQ, TEST_NEED_ID_SEQ, null, "Sequential test data setup complete.");
    Logger.log("===== EXITING setupTestData_SequentialScenario SUCCESSFULLY =====");
  } catch (error) {
    Logger.log(`!!!!!!!!!! ERROR in setupTestData_SequentialScenario !!!!!!!!!!: ${error.message}\n${error.stack}`);
    logEvent("TEST_SETUP_ERROR", "setupTestData_SequentialScenario", TEST_PROJECT_ID_SEQ, TEST_NEED_ID_SEQ, null, `ERROR: ${error.message}`);
    SpreadsheetApp.getUi().alert(`ERROR during Sequential setup: ${error.message}. Check logs!`);
  }
}

function setupTestData_ParallelScenario() { 
  Logger.log("===== ENTERING setupTestData_ParallelScenario =====");
  try {
    clearTestDataForScenario(TEST_PROJECT_ID_PAR, [TEST_NEED_ID_PAR]);

    const piSheet = getSheet("ProjectInfo");
    if (!piSheet) throw new Error("ProjectInfo sheet not found in Parallel setup.");
    piSheet.appendRow([TEST_PROJECT_ID_PAR, "Test Parallel Project", 26, "Mon 10-14", "Thu 19", 24, null, "Active", "Test Parallel", new Date(), new Date()]);
    SpreadsheetApp.flush();
    Logger.log("Appended row to ProjectInfo for Parallel test.");

    const needsSheet = getSheet("Needs");
    if (!needsSheet) throw new Error("Needs sheet not found in Parallel setup.");
    needsSheet.appendRow([TEST_NEED_ID_PAR, TEST_PROJECT_ID_PAR, "INST-VLN", "IQ-VLN-TUTTI", 2, TEST_RANKING_LIST_ID_PAR, "Parallel", null, null, "Active", "Test Parallel Need (2 spots)", null, new Date(), new Date()]); // Added CreatedDate, LastModified
    SpreadsheetApp.flush();
    Logger.log("Appended row to Needs for Parallel test.");
    
    logEvent("TEST_SETUP", "setupTestData_ParallelScenario", TEST_PROJECT_ID_PAR, TEST_NEED_ID_PAR, null, "Parallel test data setup complete.");
    Logger.log("===== EXITING setupTestData_ParallelScenario SUCCESSFULLY =====");
  } catch (error) {
    Logger.log(`!!!!!!!!!! ERROR in setupTestData_ParallelScenario !!!!!!!!!!: ${error.message}\n${error.stack}`);
    logEvent("TEST_SETUP_ERROR", "setupTestData_ParallelScenario", TEST_PROJECT_ID_PAR, TEST_NEED_ID_PAR, null, `ERROR: ${error.message}`);
    SpreadsheetApp.getUi().alert(`ERROR during Parallel setup: ${error.message}. Check logs!`);
  }
}

function setupTestData_FCFS_Filled_Scenario() {
  Logger.log("===== ENTERING setupTestData_FCFS_Filled_Scenario =====");
  const ui = SpreadsheetApp.getUi(); 

  try {
    logEvent("TEST_SETUP_DETAIL", "setupTestData_FCFS_Filled_Scenario", TEST_PROJECT_ID_FCFS, TEST_NEED_ID_FCFS_FILLED, null, "Starting cleanup phase for FCFS Filled.");
    clearTestDataForScenario(TEST_PROJECT_ID_FCFS, [TEST_NEED_ID_FCFS_FILLED, TEST_NEED_ID_FCFS_INCOMPLETE]); 
    Logger.log("Cleanup phase for FCFS Filled supposedly complete.");

    const piSheet = getSheet("ProjectInfo");
    if (!piSheet) throw new Error("ProjectInfo sheet not found in FCFS_Filled setup.");
    deleteRowByFieldValue(piSheet, "ProjectID", TEST_PROJECT_ID_FCFS, "TEST_SETUP_FCFS"); 
    SpreadsheetApp.flush();
    Logger.log(`Appending to ProjectInfo: ${TEST_PROJECT_ID_FCFS}, Test FCFS Project, ...`);
    piSheet.appendRow([TEST_PROJECT_ID_FCFS, "Test FCFS Project", 27, "Tue 10-13", "Wed 20", 24, null, "Active", "Test FCFS Project Setup", new Date(), new Date()]);
    SpreadsheetApp.flush();
    Logger.log("Appended row to ProjectInfo for FCFS test. Current last row: " + piSheet.getLastRow());

    const needsSheet = getSheet("Needs");
    if (!needsSheet) throw new Error("Needs sheet not found in FCFS_Filled setup.");
        
    Logger.log(`Appending to Needs: ${TEST_NEED_ID_FCFS_FILLED}, ${TEST_PROJECT_ID_FCFS}, MaxParallelDispatches: 3`);
    needsSheet.appendRow([
      TEST_NEED_ID_FCFS_FILLED, TEST_PROJECT_ID_FCFS, "INST-TRP", "IQ-TRP-PRINC",
      1, 
      TEST_RANKING_LIST_ID_FCFS_TRP, "FCFS", 3, 
      null, "Active", "Test FCFS Need (1 spot, 3 sent)", null, new Date(), new Date() // Added CreatedDate, LastModified
    ]);
    SpreadsheetApp.flush();
    Logger.log("Appended row to Needs for FCFS_Filled. Current last row: " + needsSheet.getLastRow());

    logEvent("TEST_SETUP", "setupTestData_FCFS_Filled_Scenario", TEST_PROJECT_ID_FCFS, TEST_NEED_ID_FCFS_FILLED, null, "FCFS Filled test data setup complete.");
    Logger.log("===== EXITING setupTestData_FCFS_Filled_Scenario SUCCESSFULLY =====");

  } catch (error) {
    Logger.log(`!!!!!!!!!! ERROR in setupTestData_FCFS_Filled_Scenario !!!!!!!!!!: ${error.message}\n${error.stack}`);
    logEvent("TEST_SETUP_ERROR", "setupTestData_FCFS_Filled_Scenario", TEST_PROJECT_ID_FCFS, TEST_NEED_ID_FCFS_FILLED, null, `ERROR: ${error.message}`);
    ui.alert(`ERROR during FCFS_Filled setup: ${error.message}. Check logs!`);
  }
}

function setupTestData_FCFS_Incomplete_Scenario() { 
    Logger.log("===== ENTERING setupTestData_FCFS_Incomplete_Scenario =====");
    const ui = SpreadsheetApp.getUi(); 

    try {
        logEvent("TEST_SETUP_DETAIL", "setupTestData_FCFS_Incomplete_Scenario", TEST_PROJECT_ID_FCFS, TEST_NEED_ID_FCFS_INCOMPLETE, null, "Starting cleanup phase for FCFS Incomplete.");
        clearTestDataForScenario(TEST_PROJECT_ID_FCFS, [TEST_NEED_ID_FCFS_FILLED, TEST_NEED_ID_FCFS_INCOMPLETE]); 
        Logger.log("Cleanup phase for FCFS Incomplete supposedly complete.");

        const piSheet = getSheet("ProjectInfo");
        if (!piSheet) throw new Error("ProjectInfo sheet not found in FCFS_Incomplete setup.");
        
        deleteRowByFieldValue(piSheet, "ProjectID", TEST_PROJECT_ID_FCFS, "TEST_SETUP_FCFS_INC");
        SpreadsheetApp.flush();
        Logger.log(`Appending to ProjectInfo: ${TEST_PROJECT_ID_FCFS}, Test FCFS Project (Incomplete Scenario), ...`);
        piSheet.appendRow([TEST_PROJECT_ID_FCFS, "Test FCFS Project (Incomplete)", 29, "Thu 10-13", "Fri 20", 24, null, "Active", "Test FCFS Inc.", new Date(), new Date()]);
        SpreadsheetApp.flush();
        Logger.log("Appended row to ProjectInfo for FCFS Incomplete test. Current last row: " + piSheet.getLastRow());

        const needsSheet = getSheet("Needs");
        if (!needsSheet) throw new Error("Needs sheet not found in FCFS_Incomplete setup.");
                
        Logger.log(`Appending to Needs: ${TEST_NEED_ID_FCFS_INCOMPLETE}, ${TEST_PROJECT_ID_FCFS}, Needed: 2, MaxParallelDispatches: 3`);
        needsSheet.appendRow([
          TEST_NEED_ID_FCFS_INCOMPLETE, TEST_PROJECT_ID_FCFS, "INST-TRP", "IQ-TRP-PRINC",
          2, 
          TEST_RANKING_LIST_ID_FCFS_TRP, "FCFS", 3, 
          null, "Active", "Test FCFS Need (2 spots, 3 sent, expect incomplete)", null, new Date(), new Date() // Added CreatedDate, LastModified
        ]);
        SpreadsheetApp.flush();
        Logger.log("Appended row to Needs for FCFS_Incomplete. Current last row: " + needsSheet.getLastRow());

        logEvent("TEST_SETUP", "setupTestData_FCFS_Incomplete_Scenario", TEST_PROJECT_ID_FCFS, TEST_NEED_ID_FCFS_INCOMPLETE, null, "FCFS Incomplete test data setup complete.");
        Logger.log("===== EXITING setupTestData_FCFS_Incomplete_Scenario SUCCESSFULLY =====");

    } catch (error) {
        Logger.log(`!!!!!!!!!! ERROR in setupTestData_FCFS_Incomplete_Scenario !!!!!!!!!!: ${error.message}\n${error.stack}`);
        logEvent("TEST_SETUP_ERROR", "setupTestData_FCFS_Incomplete_Scenario", TEST_PROJECT_ID_FCFS, TEST_NEED_ID_FCFS_INCOMPLETE, null, `ERROR: ${error.message}`);
        ui.alert(`ERROR during FCFS_Incomplete setup: ${error.message}. Check logs!`);
    }
}

function setupTestData_ReminderScenario() {
  Logger.log("===== ENTERING setupTestData_ReminderScenario =====");
  try {
    clearTestDataForScenario(TEST_PROJECT_ID_REM, [TEST_NEED_ID_REM]);

    const piSheet = getSheet("ProjectInfo");
    if (!piSheet) throw new Error("ProjectInfo sheet not found in Reminder setup.");
    piSheet.appendRow([TEST_PROJECT_ID_REM, "Test Reminder Project", 30, "Mon 10-11", "Wed 19", 2 , null, "Active", "Test Reminder", new Date(), new Date()]);
    SpreadsheetApp.flush();
    Logger.log("Appended row to ProjectInfo for Reminder test.");

    const needsSheet = getSheet("Needs");
    if (!needsSheet) throw new Error("Needs sheet not found in Reminder setup.");
    needsSheet.appendRow([TEST_NEED_ID_REM, TEST_PROJECT_ID_REM, "INST-FLT", "IQ-FLT-SOLO", 1, TEST_RANKING_LIST_ID_REM, "Sequential", null, null, "Active", "Test Reminder Need", null, new Date(), new Date()]); // Added CreatedDate, LastModified
    SpreadsheetApp.flush();
    Logger.log("Appended row to Needs for Reminder test.");
    
    if (!getConfig("ReminderPercentage")) {
        Logger.log("WARNING: ReminderPercentage not found in Configuration. Test might not work as expected. Defaulting to 50% for logic.");
    }

    logEvent("TEST_SETUP", "setupTestData_ReminderScenario", TEST_PROJECT_ID_REM, TEST_NEED_ID_REM, null, "Reminder test data setup complete.");
    Logger.log("===== EXITING setupTestData_ReminderScenario SUCCESSFULLY =====");
  } catch (error) {
    Logger.log(`!!!!!!!!!! ERROR in setupTestData_ReminderScenario !!!!!!!!!!: ${error.message}\n${error.stack}`);
    logEvent("TEST_SETUP_ERROR", "setupTestData_ReminderScenario", TEST_PROJECT_ID_REM, TEST_NEED_ID_REM, null, `ERROR: ${error.message}`);
    SpreadsheetApp.getUi().alert(`ERROR during Reminder setup: ${error.message}. Check logs!`);
  }
}


// Hjälpfunktion för tester
function findResponseTrackingEntry(rtData, needID, musicianID) {
  if(!rtData || rtData.length === 0) return null;
  const headers = rtData[0];
  const needIdCol = headers.indexOf("NeedID");
  const musicianIdCol = headers.indexOf("MusicianID");
  const statusCol = headers.indexOf("ResponseStatus");
  const dispatchIdCol = headers.indexOf("DispatchID"); 

  for (let i = 1; i < rtData.length; i++) {
    if (rtData[i][needIdCol] === needID && rtData[i][musicianIdCol] === musicianID) {
      return { 
        DispatchID: rtData[i][dispatchIdCol], 
        ResponseStatus: rtData[i][statusCol],
        rawRow: rtData[i] 
      };
    }
  }
  return null;
}

// --- Test-Execution Funktioner för varje scenario ---

function runTest_Sequential_NoThenYes() { 
  Logger.log("===== STARTING TEST: Sequential - Musician A NO, Musician B YES =====");
  let testsPassed = 0;
  let testsFailed = 0;
  const originalGmailSendEmail = GmailApp.sendEmail;
  let sentEmailsLog = [];
  GmailApp.sendEmail = function(recipient, subject, body, options) {
    sentEmailsLog.push({ recipient: recipient, subject: subject, options: options, body: body }); 
    Logger.log(`MOCK Email Sent To: ${recipient}, Subject: ${subject}`);
  };

  setupTestData_SequentialScenario();

  Logger.log("TEST: Running sendInitialRequests for Sequential...");
  sendInitialRequests();
  SpreadsheetApp.flush();

  let rtSheet = getSheet("ResponseTracking");
  let rtData = rtSheet.getDataRange().getValues();
  let dispatchToA = findResponseTrackingEntry(rtData, TEST_NEED_ID_SEQ, TEST_MUSICIAN_ID_SEQ_A);
  let musicianADetails = getMusicianDetails(TEST_MUSICIAN_ID_SEQ_A);

  if (dispatchToA && dispatchToA.ResponseStatus === "Waiting") { Logger.log("PASS: Initial request sent to Musician A (SEQ) and status is Waiting."); testsPassed++; } 
  else { Logger.log(`FAIL: Initial request to Musician A (SEQ) not found or status incorrect. Found: ${JSON.stringify(dispatchToA)}`); testsFailed++; }
  
  if (musicianADetails && sentEmailsLog.find(email => email.recipient === musicianADetails.Email)) { Logger.log("PASS: Email logged for Musician A (SEQ)."); testsPassed++; } 
  else { Logger.log(`FAIL: Email not logged for Musician A (SEQ) (Email: ${musicianADetails ? musicianADetails.Email : 'N/A'}). Log: ${JSON.stringify(sentEmailsLog)}`); testsFailed++; }
  sentEmailsLog = []; 

  if (dispatchToA && musicianADetails) {
    Logger.log("TEST: Simulating Musician A (SEQ) responding NO...");
    handleFormResponse({ namedValues: {
        [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToA.DispatchID],
        [getConfig("FormQuestion_Response") || "Svar"]: ["No"],
        [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_SEQ], 
        [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_SEQ], 
        [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musicianADetails.Email] 
    }});
    SpreadsheetApp.flush();

    rtData = rtSheet.getDataRange().getValues();
    dispatchToA = findResponseTrackingEntry(rtData, TEST_NEED_ID_SEQ, TEST_MUSICIAN_ID_SEQ_A);
    let dispatchToB = findResponseTrackingEntry(rtData, TEST_NEED_ID_SEQ, TEST_MUSICIAN_ID_SEQ_B);
    let musicianBDetails = getMusicianDetails(TEST_MUSICIAN_ID_SEQ_B);

    if (dispatchToA && dispatchToA.ResponseStatus === "No") { Logger.log("PASS: Musician A (SEQ) status updated to No."); testsPassed++; } 
    else { Logger.log(`FAIL: Musician A (SEQ) status not 'No'. Found: ${JSON.stringify(dispatchToA)}`); testsFailed++; }

    if (dispatchToB && dispatchToB.ResponseStatus === "Waiting") { Logger.log("PASS: Request sent to Musician B (SEQ) and status is Waiting."); testsPassed++; } 
    else { Logger.log(`FAIL: Request to Musician B (SEQ) not found or status incorrect. Found: ${JSON.stringify(dispatchToB)}`); testsFailed++; }
    
    if (musicianBDetails && sentEmailsLog.find(email => email.recipient === musicianBDetails.Email)) { Logger.log("PASS: Email logged for Musician B (SEQ)."); testsPassed++; } 
    else { Logger.log(`FAIL: Email not logged for Musician B (SEQ) (Email: ${musicianBDetails ? musicianBDetails.Email : 'N/A'}). Log: ${JSON.stringify(sentEmailsLog)}`); testsFailed++; }
    sentEmailsLog = [];

    if (dispatchToB && musicianBDetails) {
      Logger.log("TEST: Simulating Musician B (SEQ) responding YES...");
      handleFormResponse({ namedValues: {
          [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToB.DispatchID],
          [getConfig("FormQuestion_Response") || "Svar"]: ["Yes"],
          [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_SEQ],
          [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_SEQ],
          [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musicianBDetails.Email]
      }});
      SpreadsheetApp.flush();

      rtData = rtSheet.getDataRange().getValues();
      dispatchToB = findResponseTrackingEntry(rtData, TEST_NEED_ID_SEQ, TEST_MUSICIAN_ID_SEQ_B);
      const needDetails = getNeedDetails(TEST_NEED_ID_SEQ);

      if (dispatchToB && dispatchToB.ResponseStatus === "Yes") { Logger.log("PASS: Musician B (SEQ) status updated to Yes."); testsPassed++; } 
      else { Logger.log(`FAIL: Musician B (SEQ) status not 'Yes'. Found: ${JSON.stringify(dispatchToB)}`); testsFailed++; }
      
      if (needDetails && needDetails.NeedStatus === "Filled") { Logger.log("PASS: Need status for SEQ updated to Filled."); testsPassed++; } 
      else { Logger.log(`FAIL: Need status for SEQ not 'Filled'. Found: ${needDetails ? needDetails.NeedStatus : 'N/A'}`); testsFailed++; }
      
      if (musicianBDetails && sentEmailsLog.find(email => email.recipient === musicianBDetails.Email && email.subject.includes("Confirmation"))) { Logger.log("PASS: Acknowledgement email logged for Musician B (SEQ)."); testsPassed++; } 
      else { Logger.log(`FAIL: Acknowledgement email not logged for Musician B (SEQ). Log: ${JSON.stringify(sentEmailsLog)}`); testsFailed++; }
      
      const adminEmailVal = getConfig("AdminEmail"); // Get admin email once
      if (adminEmailVal && sentEmailsLog.find(email => email.recipient === adminEmailVal && email.subject.includes("Project Completed") && email.subject.includes(TEST_PROJECT_ID_SEQ))) { Logger.log("PASS: Admin Project Completed email logged for SEQ test."); testsPassed++; }
      else { Logger.log(`FAIL: Admin Project Completed email not logged for SEQ test (Admin Email: ${adminEmailVal}). Log: ${JSON.stringify(sentEmailsLog)}`); testsFailed++; }
      sentEmailsLog = [];
    } else { Logger.log("SKIP: Cannot simulate Musician B (SEQ) YES as dispatchToB or musicianBDetails was null."); testsFailed += 4; }
  } else { Logger.log("SKIP: Cannot simulate Musician A (SEQ) NO as dispatchToA or musicianADetails was null."); testsFailed += 8; }

  GmailApp.sendEmail = originalGmailSendEmail;
  Logger.log(`===== TEST SUMMARY: Sequential - NoThenYes | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
}


function runTest_Parallel_FillTwoSpots() {
  Logger.log("===== STARTING TEST: Parallel - Fill Two Spots (Need:2, MUS1=No, MUS2=Yes, MUS3=Yes) =====");
  let testsPassed = 0;
  let testsFailed = 0;
  const originalGmailSendEmail = GmailApp.sendEmail;
  let sentEmailsLog = [];
  GmailApp.sendEmail = function(recipient, subject, body, options) {
    sentEmailsLog.push({ recipient: recipient, subject: subject, options: options, body: body });
    Logger.log(`MOCK Email Sent To: ${recipient}, Subject: ${subject}`);
  };

  setupTestData_ParallelScenario(); 
  SpreadsheetApp.flush();

  Logger.log("TEST: Running sendInitialRequests for Parallel need...");
  sendInitialRequests();
  SpreadsheetApp.flush();

  let rtSheet = getSheet("ResponseTracking");
  let rtData = rtSheet.getDataRange().getValues();
  let dispatchToMus1_par = findResponseTrackingEntry(rtData, TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_1); 
  let dispatchToMus2_par = findResponseTrackingEntry(rtData, TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_2); 
  let musician1Details_par = getMusicianDetails(TEST_MUSICIAN_ID_PAR_1);
  let musician2Details_par = getMusicianDetails(TEST_MUSICIAN_ID_PAR_2);

  if (dispatchToMus1_par && dispatchToMus1_par.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to MUS-001 (Alice PAR) is Waiting."); } 
  else { testsFailed++; Logger.log(`FAIL: Initial request to MUS-001 (Alice PAR). Found: ${JSON.stringify(dispatchToMus1_par)}`); }
  
  if (dispatchToMus2_par && dispatchToMus2_par.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to MUS-005 (Edward PAR) is Waiting."); }
  else { testsFailed++; Logger.log(`FAIL: Initial request to MUS-005 (Edward PAR). Found: ${JSON.stringify(dispatchToMus2_par)}`); }

  if (musician1Details_par && sentEmailsLog.find(e => e.recipient === musician1Details_par.Email)) { testsPassed++; Logger.log("PASS: Email logged for MUS-001 (Alice PAR).");}
  else { testsFailed++; Logger.log(`FAIL: Email NOT logged for MUS-001 (Alice PAR).`);}
  if (musician2Details_par && sentEmailsLog.find(e => e.recipient === musician2Details_par.Email)) { testsPassed++; Logger.log("PASS: Email logged for MUS-005 (Edward PAR).");}
  else { testsFailed++; Logger.log(`FAIL: Email NOT logged for MUS-005 (Edward PAR).`);}
  sentEmailsLog = [];

  if (dispatchToMus1_par && musician1Details_par) {
    Logger.log("TEST: Simulating MUS-001 (Alice PAR) responding NO...");
    handleFormResponse({ namedValues: {
        [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToMus1_par.DispatchID],
        [getConfig("FormQuestion_Response") || "Svar"]: ["No"],
        [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_PAR],
        [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_PAR],
        [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musician1Details_par.Email]
    }});
    SpreadsheetApp.flush();

    rtData = rtSheet.getDataRange().getValues();
    dispatchToMus1_par = findResponseTrackingEntry(rtData, TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_1);
    let dispatchToMus3_par = findResponseTrackingEntry(rtData, TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_3); 
    let musician3Details_par = getMusicianDetails(TEST_MUSICIAN_ID_PAR_3);

    if (dispatchToMus1_par && dispatchToMus1_par.ResponseStatus === "No") { testsPassed++; Logger.log("PASS: MUS-001 (Alice PAR) status is No."); }
    else { testsFailed++; Logger.log(`FAIL: MUS-001 (Alice PAR) status not No. Found: ${JSON.stringify(dispatchToMus1_par)}`); }

    if (dispatchToMus3_par && dispatchToMus3_par.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: New request sent to MUS-006 (Fiona PAR) is Waiting."); }
    else { testsFailed++; Logger.log(`FAIL: New request to MUS-006 (Fiona PAR). Found: ${JSON.stringify(dispatchToMus3_par)}`); }
    
    if (musician3Details_par && sentEmailsLog.find(e => e.recipient === musician3Details_par.Email)) { testsPassed++; Logger.log("PASS: Email logged for MUS-006 (Fiona PAR).");}
    else { testsFailed++; Logger.log(`FAIL: Email NOT logged for MUS-006 (Fiona PAR). Log: ${JSON.stringify(sentEmailsLog)}`);}
    sentEmailsLog = [];
  } else {
    testsFailed+=3; 
    Logger.log("SKIP: Cannot simulate Alice (PAR) NO response as dispatchToMus1_par or musician1Details_par was not found.");
  }
  
  dispatchToMus2_par = findResponseTrackingEntry(rtSheet.getDataRange().getValues(), TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_2); 
  if (dispatchToMus2_par && musician2Details_par) {
    Logger.log("TEST: Simulating MUS-005 (Edward PAR) responding YES...");
    handleFormResponse({ namedValues: {
        [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToMus2_par.DispatchID],
        [getConfig("FormQuestion_Response") || "Svar"]: ["Yes"],
        [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_PAR],
        [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_PAR],
        [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musician2Details_par.Email]
    }});
    SpreadsheetApp.flush();

    rtData = rtSheet.getDataRange().getValues();
    dispatchToMus2_par = findResponseTrackingEntry(rtData, TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_2);
    let needDetails_par = getNeedDetails(TEST_NEED_ID_PAR);

    if (dispatchToMus2_par && dispatchToMus2_par.ResponseStatus === "Yes") { testsPassed++; Logger.log("PASS: MUS-005 (Edward PAR) status is Yes."); }
    else { testsFailed++; Logger.log(`FAIL: MUS-005 (Edward PAR) status not Yes. Found: ${JSON.stringify(dispatchToMus2_par)}`); }
    
    if (needDetails_par && needDetails_par.NeedStatus !== "Filled") { testsPassed++; Logger.log("PASS: Need status (PAR) is NOT Filled (1 of 2 spots)."); }
    else { testsFailed++; Logger.log(`FAIL: Need status (PAR) IS Filled or error. Found: ${needDetails_par ? needDetails_par.NeedStatus : 'N/A'}`); }

    if (musician2Details_par && sentEmailsLog.find(e => e.recipient === musician2Details_par.Email && e.subject.includes("Confirmation"))) { testsPassed++; Logger.log("PASS: Ack email for MUS-005 (Edward PAR).");}
    else { testsFailed++; Logger.log(`FAIL: Ack email NOT logged for MUS-005 (Edward PAR). Log: ${JSON.stringify(sentEmailsLog)}`);}
    sentEmailsLog = [];
  } else {
      testsFailed+=3;
      Logger.log("SKIP: Cannot simulate Edward (PAR) YES response as dispatchToMus2_par or musician2Details_par was not found.");
  }

  let dispatchToMus3_final_par = findResponseTrackingEntry(rtSheet.getDataRange().getValues(), TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_3);
  let musician3Details_final_par = getMusicianDetails(TEST_MUSICIAN_ID_PAR_3); 
  if (dispatchToMus3_final_par && musician3Details_final_par) {
    Logger.log("TEST: Simulating MUS-006 (Fiona PAR) responding YES...");
    handleFormResponse({ namedValues: {
        [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToMus3_final_par.DispatchID],
        [getConfig("FormQuestion_Response") || "Svar"]: ["Yes"],
        [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_PAR],
        [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_PAR],
        [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musician3Details_final_par.Email]
    }});
    SpreadsheetApp.flush();

    rtData = rtSheet.getDataRange().getValues();
    dispatchToMus3_final_par = findResponseTrackingEntry(rtData, TEST_NEED_ID_PAR, TEST_MUSICIAN_ID_PAR_3);
    let needDetails_par_final = getNeedDetails(TEST_NEED_ID_PAR);

    if (dispatchToMus3_final_par && dispatchToMus3_final_par.ResponseStatus === "Yes") { testsPassed++; Logger.log("PASS: MUS-006 (Fiona PAR) status is Yes."); }
    else { testsFailed++; Logger.log(`FAIL: MUS-006 (Fiona PAR) status not Yes. Found: ${JSON.stringify(dispatchToMus3_final_par)}`); }
    
    if (needDetails_par_final && needDetails_par_final.NeedStatus === "Filled") { testsPassed++; Logger.log("PASS: Need status (PAR) IS NOW Filled."); }
    else { testsFailed++; Logger.log(`FAIL: Need status (PAR) NOT Filled. Found: ${needDetails_par_final ? needDetails_par_final.NeedStatus : 'N/A'}`); }

    if (musician3Details_final_par && sentEmailsLog.find(e => e.recipient === musician3Details_final_par.Email && e.subject.includes("Confirmation"))) { testsPassed++; Logger.log("PASS: Ack email for MUS-006 (Fiona PAR).");}
    else { testsFailed++; Logger.log(`FAIL: Ack email NOT logged for MUS-006 (Fiona PAR). Log: ${JSON.stringify(sentEmailsLog)}`);}
    
    const adminEmailVal = getConfig("AdminEmail"); // Get admin email once
    if (getConfig("NotifyAdmin_OnNeedFilled") === "YES" && adminEmailVal && sentEmailsLog.find(e => e.recipient === adminEmailVal && e.subject.includes("Need Filled") && e.options && e.options.htmlBody && e.options.htmlBody.includes(TEST_NEED_ID_PAR))) { testsPassed++; Logger.log("PASS: Admin 'Need Filled' email logged for PAR test.");}
    else { testsFailed++; Logger.log(`FAIL: Admin 'Need Filled' email NOT logged for PAR test (Check NotifyAdmin_OnNeedFilled setting or Admin Email: ${adminEmailVal}. Log: ${JSON.stringify(sentEmailsLog)})`);}
    
    if (adminEmailVal && sentEmailsLog.find(e => e.recipient === adminEmailVal && e.subject.includes("Project Completed") && e.subject.includes(TEST_PROJECT_ID_PAR))) { Logger.log("PASS: Admin Project Completed email logged for PAR test."); testsPassed++; }
    else { testsFailed++; Logger.log(`FAIL: Admin Project Completed email not logged for PAR test (Admin Email: ${adminEmailVal}). Log: ${JSON.stringify(sentEmailsLog)}`); }
    sentEmailsLog = [];
  } else {
      testsFailed+=5; 
      Logger.log("SKIP: Cannot simulate Fiona (PAR) YES response as dispatchToMus3_final_par or musician3Details_final_par was not found.");
  }

  GmailApp.sendEmail = originalGmailSendEmail;
  Logger.log(`===== TEST SUMMARY: Parallel - FillTwoSpots | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
}

// runTest_FCFS_Scenario_Filled (fullt implementerad)
function runTest_FCFS_Scenario_Filled() {
    Logger.log("===== STARTING TEST: FCFS - Filled (Need:1, Sent:3, MusX=Yes, MusY=YesLate, MusZ=No) =====");
    let testsPassed = 0;
    let testsFailed = 0;
    const originalGmailSendEmail = GmailApp.sendEmail;
    let sentEmailsLog = [];
    GmailApp.sendEmail = function(recipient, subject, body, options) {
        sentEmailsLog.push({ recipient: recipient, subject: subject, options: options, body: body });
        Logger.log(`MOCK Email Sent To: ${recipient}, Subject: ${subject}`);
    };

    setupTestData_FCFS_Filled_Scenario(); 
    SpreadsheetApp.flush();

    Logger.log("TEST: Running sendInitialRequests for FCFS (Filled) need...");
    sendInitialRequests();
    SpreadsheetApp.flush();

    let rtSheet = getSheet("ResponseTracking");
    let rtData = rtSheet.getDataRange().getValues();

    let musicianXDetails_fcfs = getMusicianDetails(TEST_MUSICIAN_ID_FCFS_X);
    let musicianYDetails_fcfs = getMusicianDetails(TEST_MUSICIAN_ID_FCFS_Y);
    let musicianZDetails_fcfs = getMusicianDetails(TEST_MUSICIAN_ID_FCFS_Z);

    let dispatchToX_fcfs = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_X);
    let dispatchToY_fcfs = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_Y);
    let dispatchToZ_fcfs = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_Z);

    let initialEmailCount_fcfs = 0;
    if (musicianXDetails_fcfs && sentEmailsLog.find(e => e.recipient === musicianXDetails_fcfs.Email)) initialEmailCount_fcfs++;
    if (musicianYDetails_fcfs && sentEmailsLog.find(e => e.recipient === musicianYDetails_fcfs.Email)) initialEmailCount_fcfs++;
    if (musicianZDetails_fcfs && sentEmailsLog.find(e => e.recipient === musicianZDetails_fcfs.Email)) initialEmailCount_fcfs++;
    
    if (dispatchToX_fcfs && dispatchToX_fcfs.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to Musician X (FCFS) is Waiting."); } 
    else { testsFailed++; Logger.log(`FAIL: Initial request to Musician X (FCFS). Found: ${JSON.stringify(dispatchToX_fcfs)}`); }
    if (dispatchToY_fcfs && dispatchToY_fcfs.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to Musician Y (FCFS) is Waiting."); } 
    else { testsFailed++; Logger.log(`FAIL: Initial request to Musician Y (FCFS). Found: ${JSON.stringify(dispatchToY_fcfs)}`); }
    if (dispatchToZ_fcfs && dispatchToZ_fcfs.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to Musician Z (FCFS) is Waiting."); } 
    else { testsFailed++; Logger.log(`FAIL: Initial request to Musician Z (FCFS). Found: ${JSON.stringify(dispatchToZ_fcfs)}`); }
    
    if (initialEmailCount_fcfs === 3) { testsPassed++; Logger.log("PASS: Correct number of initial emails (3) logged for FCFS Filled."); }
    else { testsFailed++; Logger.log(`FAIL: Incorrect number of initial emails for FCFS Filled. Expected 3, Found: ${initialEmailCount_fcfs}.`); }
    sentEmailsLog = [];

    if (dispatchToX_fcfs && musicianXDetails_fcfs) {
        Logger.log("TEST: Simulating Musician X (FCFS) responding YES...");
        handleFormResponse({ namedValues: {
            [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToX_fcfs.DispatchID],
            [getConfig("FormQuestion_Response") || "Svar"]: ["Yes"],
            [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_FCFS],
            [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_FCFS_FILLED],
            [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musicianXDetails_fcfs.Email]
        }});
        SpreadsheetApp.flush();

        rtData = rtSheet.getDataRange().getValues();
        dispatchToX_fcfs = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_X);
        let needDetails_fcfs = getNeedDetails(TEST_NEED_ID_FCFS_FILLED);

        if (dispatchToX_fcfs && dispatchToX_fcfs.ResponseStatus === "Yes") { testsPassed++; Logger.log("PASS: Musician X (FCFS) status is Yes."); } 
        else { testsFailed++; Logger.log(`FAIL: Musician X (FCFS) status not Yes. Found: ${JSON.stringify(dispatchToX_fcfs)}`); }

        if (needDetails_fcfs && needDetails_fcfs.NeedStatus === "Filled") { testsPassed++; Logger.log("PASS: Need status (FCFS) IS Filled after X said Yes."); } 
        else { testsFailed++; Logger.log(`FAIL: Need status (FCFS) NOT Filled. Found: ${needDetails_fcfs ? needDetails_fcfs.NeedStatus : 'N/A'}`); }
        
        if (sentEmailsLog.find(e => e.recipient === musicianXDetails_fcfs.Email && e.subject.includes("Confirmation"))) { testsPassed++; Logger.log("PASS: Ack email logged for Musician X (FCFS).");}
        else { testsFailed++; Logger.log(`FAIL: Ack email NOT logged for Musician X (FCFS). Log: ${JSON.stringify(sentEmailsLog)}`);}
        sentEmailsLog = [];
    } else { testsFailed += 3; Logger.log("SKIP: Cannot simulate Musician X (FCFS) YES.");}

    dispatchToY_fcfs = findResponseTrackingEntry(rtSheet.getDataRange().getValues(), TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_Y);
    if (dispatchToY_fcfs && musicianYDetails_fcfs) {
        Logger.log("TEST: Simulating Musician Y (FCFS) responding YES (late)...");
        handleFormResponse({ namedValues: {
            [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToY_fcfs.DispatchID],
            [getConfig("FormQuestion_Response") || "Svar"]: ["Yes"],
            [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_FCFS],
            [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_FCFS_FILLED],
            [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musicianYDetails_fcfs.Email]
        }});
        SpreadsheetApp.flush();

        rtData = rtSheet.getDataRange().getValues();
        dispatchToY_fcfs = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_Y);

        if (dispatchToY_fcfs && dispatchToY_fcfs.ResponseStatus === "Declined_AlreadyFilled") { testsPassed++; Logger.log("PASS: Musician Y (FCFS) status is Declined_AlreadyFilled."); } 
        else { testsFailed++; Logger.log(`FAIL: Musician Y (FCFS) status not Declined_AlreadyFilled. Found: ${JSON.stringify(dispatchToY_fcfs)}`); }
        
        const alreadyFilledEmailToY = sentEmailsLog.find(e => e.recipient === musicianYDetails_fcfs.Email);
        if (alreadyFilledEmailToY && alreadyFilledEmailToY.options && alreadyFilledEmailToY.options.htmlBody && 
            (alreadyFilledEmailToY.options.htmlBody.toLowerCase().includes("already filled") || alreadyFilledEmailToY.options.htmlBody.toLowerCase().includes("tyvärr redan fylld")) ) { 
            testsPassed++; Logger.log("PASS: 'Already Filled' email content verified for Musician Y (FCFS).");
        } else { 
            testsFailed++; Logger.log(`FAIL: 'Already Filled' email content NOT verified for Musician Y (FCFS). Log: ${JSON.stringify(sentEmailsLog)}`);
        }
        sentEmailsLog = [];
    } else { testsFailed += 2; Logger.log("SKIP: Cannot simulate Musician Y (FCFS) YES (late)."); }

    dispatchToZ_fcfs = findResponseTrackingEntry(rtSheet.getDataRange().getValues(), TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_Z);
    if (dispatchToZ_fcfs && musicianZDetails_fcfs) {
        Logger.log("TEST: Simulating Musician Z (FCFS) responding NO...");
        handleFormResponse({ namedValues: {
            [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [dispatchToZ_fcfs.DispatchID],
            [getConfig("FormQuestion_Response") || "Svar"]: ["No"],
            [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_FCFS],
            [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_FCFS_FILLED],
            [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [musicianZDetails_fcfs.Email]
        }});
        SpreadsheetApp.flush();
        
        rtData = rtSheet.getDataRange().getValues();
        dispatchToZ_fcfs = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_FILLED, TEST_MUSICIAN_ID_FCFS_Z);

        if (dispatchToZ_fcfs && dispatchToZ_fcfs.ResponseStatus === "No") { testsPassed++; Logger.log("PASS: Musician Z (FCFS) status is No."); } 
        else { testsFailed++; Logger.log(`FAIL: Musician Z (FCFS) status not No. Found: ${JSON.stringify(dispatchToZ_fcfs)}`); }
        
        const adminEmailVal = getConfig("AdminEmail");
        if (adminEmailVal && sentEmailsLog.find(e => e.recipient === adminEmailVal && e.subject.includes("FCFS Batch Incomplete"))) {
            testsFailed++; Logger.log("FAIL: Admin 'FCFS Batch Incomplete' email WAS sent, but should NOT have been (need is filled).");
        } else {
            testsPassed++; Logger.log("PASS: Admin 'FCFS Batch Incomplete' email was NOT sent (Correct, as need is filled).");
        }
        sentEmailsLog = [];
    } else { testsFailed += 2; Logger.log("SKIP: Cannot simulate Musician Z (FCFS) NO."); }
    
    const projectDetailsFinal_fcfs = getProjectDetails(TEST_PROJECT_ID_FCFS);
    if (projectDetailsFinal_fcfs && projectDetailsFinal_fcfs.ProjectStatus === "Completed") {
        testsPassed++; Logger.log("PASS: Project status for FCFS test is Completed.");
        const adminEmailVal = getConfig("AdminEmail");
        if (adminEmailVal && sentEmailsLog.find(e => e.recipient === adminEmailVal && e.subject.includes("Project Completed") && e.subject.includes(TEST_PROJECT_ID_FCFS))) {
            testsPassed++; Logger.log("PASS: Admin Project Completed email logged for FCFS test.");
        } else {
            testsFailed++; Logger.log(`FAIL: Admin Project Completed email not logged for FCFS test (Admin Email: ${adminEmailVal}). Log: ${JSON.stringify(sentEmailsLog)}`);
        }
    } else {
        testsFailed += 2; 
        Logger.log(`FAIL: Project status for FCFS test not Completed. Found: ${projectDetailsFinal_fcfs ? projectDetailsFinal_fcfs.ProjectStatus : 'N/A'}`);
    }
    sentEmailsLog = [];

    GmailApp.sendEmail = originalGmailSendEmail;
    Logger.log(`===== TEST SUMMARY: FCFS - Filled | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
}


function runTest_FCFS_Scenario_BatchIncomplete() {
    Logger.log("===== STARTING TEST: FCFS - Batch Incomplete (Need:2, Sent:3, All No) =====");
    let testsPassed = 0;
    let testsFailed = 0;
    const originalGmailSendEmail = GmailApp.sendEmail;
    let sentEmailsLog = [];
    GmailApp.sendEmail = function(recipient, subject, body, options) {
        sentEmailsLog.push({ recipient: recipient, subject: subject, options: options, body: body });
        Logger.log(`MOCK Email Sent To: ${recipient}, Subject: ${subject}`);
    };

    setupTestData_FCFS_Incomplete_Scenario(); 
    SpreadsheetApp.flush();

    const needsSheet = getSheet("Needs"); 
    if(!needsSheet || needsSheet.createTextFinder(TEST_NEED_ID_FCFS_INCOMPLETE).findNext() == null){
        Logger.log("ABORT FCFS Incomplete Test: Setup function did not create the test need correctly in Needs sheet.");
        testsFailed = 99; 
        GmailApp.sendEmail = originalGmailSendEmail;
        Logger.log(`===== TEST SUMMARY: FCFS - Batch Incomplete | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
        return;
    }


    Logger.log("TEST: Running sendInitialRequests for FCFS (Incomplete) need...");
    sendInitialRequests();
    SpreadsheetApp.flush();

    let rtSheet = getSheet("ResponseTracking");
    let rtData = rtSheet.getDataRange().getValues();

    let musicianXDetails_fcfs_inc = getMusicianDetails(TEST_MUSICIAN_ID_FCFS_X);
    let musicianYDetails_fcfs_inc = getMusicianDetails(TEST_MUSICIAN_ID_FCFS_Y);
    let musicianZDetails_fcfs_inc = getMusicianDetails(TEST_MUSICIAN_ID_FCFS_Z);

    let dispatchToX_fcfs_inc = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_INCOMPLETE, TEST_MUSICIAN_ID_FCFS_X);
    let dispatchToY_fcfs_inc = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_INCOMPLETE, TEST_MUSICIAN_ID_FCFS_Y);
    let dispatchToZ_fcfs_inc = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_INCOMPLETE, TEST_MUSICIAN_ID_FCFS_Z);

    let initialEmailCount_fcfs_inc = 0;
    if (musicianXDetails_fcfs_inc && sentEmailsLog.find(e => e.recipient === musicianXDetails_fcfs_inc.Email)) initialEmailCount_fcfs_inc++;
    if (musicianYDetails_fcfs_inc && sentEmailsLog.find(e => e.recipient === musicianYDetails_fcfs_inc.Email)) initialEmailCount_fcfs_inc++;
    if (musicianZDetails_fcfs_inc && sentEmailsLog.find(e => e.recipient === musicianZDetails_fcfs_inc.Email)) initialEmailCount_fcfs_inc++;
    
    if (dispatchToX_fcfs_inc && dispatchToX_fcfs_inc.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to Musician X (FCFS Inc) is Waiting."); } 
    else { testsFailed++; Logger.log(`FAIL: Initial request to Musician X (FCFS Inc). Found: ${JSON.stringify(dispatchToX_fcfs_inc)}`); }
    if (dispatchToY_fcfs_inc && dispatchToY_fcfs_inc.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to Musician Y (FCFS Inc) is Waiting."); } 
    else { testsFailed++; Logger.log(`FAIL: Initial request to Musician Y (FCFS Inc). Found: ${JSON.stringify(dispatchToY_fcfs_inc)}`); }
    if (dispatchToZ_fcfs_inc && dispatchToZ_fcfs_inc.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request to Musician Z (FCFS Inc) is Waiting."); } 
    else { testsFailed++; Logger.log(`FAIL: Initial request to Musician Z (FCFS Inc). Found: ${JSON.stringify(dispatchToZ_fcfs_inc)}`); }
    
    if (initialEmailCount_fcfs_inc === 3) { testsPassed++; Logger.log("PASS: Correct number of initial emails (3) logged for FCFS Incomplete."); }
    else { testsFailed++; Logger.log(`FAIL: Incorrect number of initial emails for FCFS Incomplete. Expected 3, Found: ${initialEmailCount_fcfs_inc}.`); }
    sentEmailsLog = []; 

    const musiciansToSimulateNo = [
        { details: musicianXDetails_fcfs_inc, dispatch: dispatchToX_fcfs_inc, id: TEST_MUSICIAN_ID_FCFS_X },
        { details: musicianYDetails_fcfs_inc, dispatch: dispatchToY_fcfs_inc, id: TEST_MUSICIAN_ID_FCFS_Y },
        { details: musicianZDetails_fcfs_inc, dispatch: dispatchToZ_fcfs_inc, id: TEST_MUSICIAN_ID_FCFS_Z } 
    ];

    for (const item of musiciansToSimulateNo) {
        if (item.dispatch && item.details) {
            Logger.log(`TEST: Simulating Musician ${item.id} (FCFS Inc) responding NO...`);
            handleFormResponse({ namedValues: {
                [getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)"]: [item.dispatch.DispatchID],
                [getConfig("FormQuestion_Response") || "Svar"]: ["No"],
                [getConfig("FormQuestion_ProjectID_FieldName") || "ProjectID (Dummy)"]: [TEST_PROJECT_ID_FCFS],
                [getConfig("FormQuestion_NeedID_FieldName") || "NeedID (Dummy)"]: [TEST_NEED_ID_FCFS_INCOMPLETE],
                [getConfig("FormQuestion_Email_FieldName") || "Email (Dummy)"]: [item.details.Email]
            }});
            SpreadsheetApp.flush();
            
            rtData = rtSheet.getDataRange().getValues(); 
            let updatedDispatch = findResponseTrackingEntry(rtData, TEST_NEED_ID_FCFS_INCOMPLETE, item.id);
            if (updatedDispatch && updatedDispatch.ResponseStatus === "No") { testsPassed++; Logger.log(`PASS: Musician ${item.id} (FCFS Inc) status is No.`); } 
            else { testsFailed++; Logger.log(`FAIL: Musician ${item.id} (FCFS Inc) status not No. Found: ${JSON.stringify(updatedDispatch)}`); }
        } else {
            testsFailed++; 
            Logger.log(`SKIP: Cannot simulate NO for Musician ${item.id} (FCFS Inc) as dispatch or details were not found. Dispatch: ${JSON.stringify(item.dispatch)}, Details: ${JSON.stringify(item.details)}`);
        }
    }
    sentEmailsLog = []; 
    Utilities.sleep(1000); 

    const adminEmailVal = getConfig("AdminEmail");
    const needDetails_fcfs_inc_final = getNeedDetails(TEST_NEED_ID_FCFS_INCOMPLETE);

    Logger.log(`DEBUG: Checking sentEmailsLog for Admin FCFS Incomplete. Admin Email: ${adminEmailVal}. Log content: ${JSON.stringify(sentEmailsLog)}`);

    const adminIncompleteNotice = sentEmailsLog.find(e => 
        e.recipient === adminEmailVal && 
        e.subject && e.subject.includes("FCFS Batch Incomplete") && 
        e.options && e.options.htmlBody && e.options.htmlBody.includes(TEST_NEED_ID_FCFS_INCOMPLETE)
    );

    if (adminIncompleteNotice) {
        testsPassed++; Logger.log("PASS: Admin 'FCFS Batch Incomplete' email WAS sent.");
    } else {
        testsFailed++; Logger.log(`FAIL: Admin 'FCFS Batch Incomplete' email was NOT sent or content incorrect. Recipient: ${adminEmailVal}. Log: ${JSON.stringify(sentEmailsLog)}`);
    }
    
    if (needDetails_fcfs_inc_final && needDetails_fcfs_inc_final.NeedStatus === "Active") { testsPassed++; Logger.log("PASS: Need status (FCFS Inc) is still Active."); } 
    else { testsFailed++; Logger.log(`FAIL: Need status (FCFS Inc) is not Active. Found: ${needDetails_fcfs_inc_final ? needDetails_fcfs_inc_final.NeedStatus : 'N/A'}`); }

    const projectDetailsFinal_fcfs_inc = getProjectDetails(TEST_PROJECT_ID_FCFS);
    if (projectDetailsFinal_fcfs_inc && projectDetailsFinal_fcfs_inc.ProjectStatus !== "Completed") {
        testsPassed++; Logger.log("PASS: Project status for FCFS Incomplete test is NOT Completed.");
    } else {
        testsFailed++; 
        Logger.log(`FAIL: Project status for FCFS Incomplete test IS Completed or project not found. Found: ${projectDetailsFinal_fcfs_inc ? projectDetailsFinal_fcfs_inc.ProjectStatus : 'N/A'}`);
    }

    GmailApp.sendEmail = originalGmailSendEmail; 
    Logger.log(`===== TEST SUMMARY: FCFS - Batch Incomplete | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
}


function runTest_Reminder() {
    Logger.log("===== STARTING TEST: Reminder Scenario =====");
    let testsPassed = 0;
    let testsFailed = 0;
    const originalGmailSendEmail = GmailApp.sendEmail;
    let sentEmailsLog = [];
    GmailApp.sendEmail = function(recipient, subject, body, options) {
        sentEmailsLog.push({ recipient: recipient, subject: subject, options: options, body: body });
        Logger.log(`MOCK Email Sent To: ${recipient}, Subject: ${subject}`);
    };

    setupTestData_ReminderScenario(); 
    SpreadsheetApp.flush();

    Logger.log("TEST: Running sendInitialRequests for Reminder test need...");
    sendInitialRequests();
    SpreadsheetApp.flush();

    let rtSheet = getSheet("ResponseTracking");
    let rtData = rtSheet.getDataRange().getValues();
    let dispatchToMusician = findResponseTrackingEntry(rtData, TEST_NEED_ID_REM, TEST_MUSICIAN_ID_REM);
    let musicianDetails_rem = getMusicianDetails(TEST_MUSICIAN_ID_REM);

    if (!dispatchToMusician || !musicianDetails_rem) {
        Logger.log("FAIL: Setup for Reminder test failed. Musician or dispatch not found initially.");
        testsFailed += 5; 
        GmailApp.sendEmail = originalGmailSendEmail;
        Logger.log(`===== TEST SUMMARY: Reminder Scenario | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
        return;
    }

    if (dispatchToMusician.ResponseStatus === "Waiting") { testsPassed++; Logger.log("PASS: Initial request (REM) sent and status is Waiting."); } 
    else { testsFailed++; Logger.log(`FAIL: Initial request (REM) status incorrect. Found: ${JSON.stringify(dispatchToMusician)}`); }
    
    if (sentEmailsLog.find(e => e.recipient === musicianDetails_rem.Email && e.subject.includes("Request"))) { testsPassed++; Logger.log("PASS: Initial request email (REM) logged.");}
    else { testsFailed++; Logger.log(`FAIL: Initial request email (REM) NOT logged. Log: ${JSON.stringify(sentEmailsLog)}`);}
    sentEmailsLog = []; 

    const reminderPercentage = parseFloat(getConfig("ReminderPercentage") || 50);
    const projectDetails_rem = getProjectDetails(TEST_PROJECT_ID_REM);
    if (!projectDetails_rem) {
      Logger.log("FAIL: Could not get project details for Reminder test.");
      testsFailed += 3; 
      GmailApp.sendEmail = originalGmailSendEmail;
      Logger.log(`===== TEST SUMMARY: Reminder Scenario | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
      return;
    }
    const responseDeadlineHours_rem = parseFloat(projectDetails_rem.ResponseDeadlineHours);
    
    if (isNaN(responseDeadlineHours_rem) || responseDeadlineHours_rem <=0) {
        Logger.log("FAIL: ResponseDeadlineHours for reminder test project is invalid or zero. Cannot test reminder accurately.");
        testsFailed++;
    } else {
        const deadlineMillis = responseDeadlineHours_rem * 60 * 60 * 1000;
        const reminderPointMillis = deadlineMillis * (reminderPercentage / 100);
        const timeToShiftBack = reminderPointMillis + (1 * 60 * 1000); 

        const newSentTimestamp = new Date(new Date().getTime() - timeToShiftBack);
        
        const rtHeaders = rtSheet.getRange(1,1,1,rtSheet.getLastColumn()).getValues()[0];
        const sentTimeColIndex = rtHeaders.indexOf("SentTimestamp") + 1;
        const dispatchIdColIndex_rt = rtHeaders.indexOf("DispatchID"); 

        let dispatchRowInSheet = -1;
        rtData = rtSheet.getDataRange().getValues(); 
        for(let k=1; k < rtData.length; k++){
            if(rtData[k][dispatchIdColIndex_rt] === dispatchToMusician.DispatchID){
                dispatchRowInSheet = k + 1;
                break;
            }
        }

        if (sentTimeColIndex > 0 && dispatchRowInSheet > 1) {
            rtSheet.getRange(dispatchRowInSheet, sentTimeColIndex).setValue(newSentTimestamp);
            const deadlineTimeColIndex = rtHeaders.indexOf("DeadlineTimestamp") + 1;
            if (deadlineTimeColIndex > 0) { 
                const newDeadlineTimestamp = new Date(newSentTimestamp.getTime() + deadlineMillis);
                rtSheet.getRange(dispatchRowInSheet, deadlineTimeColIndex).setValue(newDeadlineTimestamp);
            }
            SpreadsheetApp.flush();
            Logger.log(`TEST: Manipulated SentTimestamp for ${dispatchToMusician.DispatchID} to ${newSentTimestamp.toISOString()} to trigger reminder.`);

            Logger.log("TEST: Running checkReminders()...");
            checkReminders();
            SpreadsheetApp.flush();

            rtData = rtSheet.getDataRange().getValues(); 
            let updatedDispatch = findResponseTrackingEntry(rtData, TEST_NEED_ID_REM, TEST_MUSICIAN_ID_REM); 

            const reminderSentColIndex = rtHeaders.indexOf("ReminderSentTimestamp");
            if (updatedDispatch && updatedDispatch.rawRow && updatedDispatch.rawRow[reminderSentColIndex]) { testsPassed++; Logger.log("PASS: ReminderSentTimestamp (REM) is populated."); }
            else { testsFailed++; Logger.log(`FAIL: ReminderSentTimestamp (REM) is NOT populated. Found: ${updatedDispatch ? updatedDispatch.rawRow : 'N/A'}. Index: ${reminderSentColIndex}`); }


            if (sentEmailsLog.find(e => e.recipient === musicianDetails_rem.Email && e.subject.includes("Reminder"))) { testsPassed++; Logger.log("PASS: Reminder email (REM) logged.");}
            else { testsFailed++; Logger.log(`FAIL: Reminder email (REM) NOT logged. Log: ${JSON.stringify(sentEmailsLog)}`);}
            
            sentEmailsLog = []; 
            Logger.log("TEST: Running checkReminders() again (should not send another)...");
            checkReminders(); // Second call
            SpreadsheetApp.flush();

            if (sentEmailsLog.length === 0) { testsPassed++; Logger.log("PASS: No new reminder email sent on second checkReminders() call (Correct).");}
            else { testsFailed++; Logger.log(`FAIL: New email WAS sent on second checkReminders() call. Log: ${JSON.stringify(sentEmailsLog)}`);}

        } else {
            Logger.log(`FAIL: Could not find SentTimestamp column (${sentTimeColIndex}) or dispatch row (${dispatchRowInSheet}) to manipulate for reminder test.`);
            testsFailed += 3; 
        }
    }
    sentEmailsLog = [];

    GmailApp.sendEmail = originalGmailSendEmail;
    Logger.log(`===== TEST SUMMARY: Reminder Scenario | Passed: ${testsPassed}, Failed: ${testsFailed} =====`);
}


// --- Huvudfunktion för att köra alla tester ---
function runAllAutomatedTests_MENU(){
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert("Run All Automated Tests?", 
                              "This will modify test data in your sheets and log extensively. Are you sure you want to proceed?\n\nNOTE: Ensure your MusicianDB contains the necessary test musicians and ranking lists as per comments in setupTestData_... functions.", 
                              ui.ButtonSet.YES_NO);
  if (response !== ui.Button.YES) {
    ui.alert("Test run cancelled by user.");
    return;
  }
  
  Logger.log("<<<<< RUNNING ALL AUTOMATED TESTS >>>>>");
  
  runTest_Sequential_NoThenYes();
  SpreadsheetApp.flush(); 

  runTest_Parallel_FillTwoSpots();
  SpreadsheetApp.flush();

  runTest_FCFS_Scenario_Filled(); 
  SpreadsheetApp.flush();

  runTest_FCFS_Scenario_BatchIncomplete(); 
  SpreadsheetApp.flush();

  runTest_Reminder(); 
  SpreadsheetApp.flush();
  
  Logger.log("<<<<< ALL AUTOMATED TESTS COMPLETED (som är implementerade) >>>>>");
  ui.alert("All implemented automated tests have been executed. Check the Execution Logs for individual test summaries and details.");
}
// ==========================================================================
//  BLOCK 1: CORE HELPER FUNCTIONS & INITIALIZATION
// ==========================================================================

/**
 * Hämtar ett värde från Configuration-fliken.
 * @param {string} key Nyckeln för inställningen.
 * @return {string|null} Värdet för inställningen, eller null om nyckeln inte hittas.
 */
function getConfig(key) {
  try {
    const configSheet = SpreadsheetApp.openById(OPERATIONS_SPREADSHEET_ID).getSheetByName("Configuration");
    if (!configSheet) {
      Logger.log("ERROR: Configuration sheet not found in getConfig.");
      return null;
    }
    const data = configSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) { // Börjar från rad 1 (efter rubriker)
      if (data[i][0] === key) {
        return data[i][1];
      }
    }
    // Logger.log(`WARNING: Key "${key}" not found in Configuration.`); // Reduced verbosity for common misses during setup
    return null;
  } catch (e) {
    Logger.log(`ERROR in getConfig for key "${key}": ${e.message}`);
    return null;
  }
}

/**
 * Loggar en händelse till EventLog-fliken.
 * @param {string} logType Typ av logg (INFO, ERROR, WARNING, DISPATCH, etc.).
 * @param {string} functionName Namnet på funktionen som genererade loggen.
 * @param {string|null} projectID Relevant ProjectID (valfritt).
 * @param {string|null} needID Relevant NeedID (valfritt).
 * @param {string|null} musicianID Relevant MusicianID (valfritt).
 * @param {string} message Detaljerad beskrivning.
 */
function logEvent(logType, functionName, projectID, needID, musicianID, message) {
  try {
    const logSheet = SpreadsheetApp.openById(OPERATIONS_SPREADSHEET_ID).getSheetByName("EventLog");
    if (!logSheet) {
      Logger.log("CRITICAL ERROR: EventLog sheet not found. Could not log: " + message);
      return;
    }
    const timestamp = new Date();
    logSheet.appendRow([timestamp, logType, functionName, projectID || "", needID || "", musicianID || "", message]);
  } catch (e) {
    Logger.log(`CRITICAL ERROR during logging: ${e.message}. Original message: ${message}`);
  }
}

/**
 * Genererar ett unikt ID (UUID).
 * @param {string} prefix (Optional) A prefix for the ID.
 * @return {string} Ett unikt ID.
 */
function generateUniqueId(prefix = "") {
  return prefix + Utilities.getUuid();
}

/**
 * Hämtar ett specifikt sheet-objekt från en spreadsheet.
 * @param {string} sheetName Namnet på fliken.
 * @param {string} spreadsheetId (Valfritt) ID för spreadsheeten. Om utelämnat, används den aktiva (Operations).
 * @return {GoogleAppsScript.Spreadsheet.Sheet|null} Sheet-objektet eller null om det inte hittas.
 */
function getSheet(sheetName, spreadsheetId = null) {
  try {
    const ssIdToUse = spreadsheetId || OPERATIONS_SPREADSHEET_ID;
    if (!ssIdToUse) {
        logEvent("CRITICAL ERROR", "getSheet", null, null, null, `Spreadsheet ID is null or undefined. Cannot open sheet "${sheetName}". OPERATIONS_SPREADSHEET_ID might be uninitialized if called very early.`);
        return null;
    }
    const ss = SpreadsheetApp.openById(ssIdToUse);
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      logEvent("ERROR", "getSheet", null, null, null, `Sheet "${sheetName}" not found in spreadsheet ID "${ssIdToUse}".`);
      return null;
    }
    return sheet;
  } catch (e) {
    logEvent("ERROR", "getSheet", null, null, null, `Error accessing sheet "${sheetName}": ${e.message}`);
    return null;
  }
}

/**
 * Hämtar Spreadsheet-objektet för Musikerdatabasen.
 * @return {GoogleAppsScript.Spreadsheet.Spreadsheet|null} Spreadsheet-objektet eller null vid fel.
 */
function getMusicianDatabaseSpreadsheet() {
  const musicianDbId = getConfig("MusicianDatabaseID");
  if (!musicianDbId) {
    logEvent("CRITICAL ERROR", "getMusicianDatabaseSpreadsheet", null, null, null, "MusicianDatabaseID not found in Configuration. Ensure it is set in the Configuration sheet of the Operations spreadsheet.");
    return null;
  }
  try {
    return SpreadsheetApp.openById(musicianDbId);
  } catch (e) {
    logEvent("CRITICAL ERROR", "getMusicianDatabaseSpreadsheet", null, null, null, `Failed to open Musician Database (ID: ${musicianDbId}): ${e.message}`);
    return null;
  }
}

/**
 * Skapar en anpassad meny i Spreadsheeteet när det öppnas.
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu("Orchestra Admin")
    .addItem("▶️ Send Initial Requests (Manual)", "sendInitialRequests_MENU") 
    .addSeparator()
    .addItem("🔄 Check Reminders (Manual)", "checkReminders_MENU") 
    .addItem("⏰ Check Deadlines (Manual)", "checkDeadlines_MENU") 
    .addItem("📊 Check Project Completion (Manual)", "checkProjectCompletion_MENU") 
    .addSeparator()
    .addItem("📦 Archive Project...", "archiveProject_MENU") 
    .addItem("🗑️ Reset Project...", "resetProject_MENU") 
    .addSeparator()
    .addItem("🧪 Run All Automated Tests", "runAllAutomatedTests_MENU")
    .addItem("🔧 Setup Sheets (RUN ONCE!)", "setupInitialSpreadsheetsAndSheets") 
    .addToUi();
}

// Testfunktion för att verifiera getConfig och logEvent
function testHelperFunctions() {
  const adminEmail = getConfig("AdminEmail");
  if (adminEmail) {
    logEvent("INFO", "testHelperFunctions", null, null, null, `Successfully retrieved AdminEmail: ${adminEmail}`);
    SpreadsheetApp.getUi().alert(`Admin Email from Config: ${adminEmail}`);
  } else {
    logEvent("ERROR", "testHelperFunctions", null, null, null, "Could not retrieve AdminEmail from Configuration.");
    SpreadsheetApp.getUi().alert("Could not retrieve AdminEmail. Check Configuration and Logs.");
  }

  const musicianDB_ID = getConfig("MusicianDatabaseID");
  if(musicianDB_ID){
    logEvent("INFO", "testHelperFunctions", null, null, null, `Musician DB ID: ${musicianDB_ID}`);
  } else {
    logEvent("ERROR", "testHelperFunctions", null, null, null, "Could not retrieve MusicianDatabaseID.");
  }

  const newId = generateUniqueId("TEST_");
  logEvent("INFO", "testHelperFunctions", null, null, null, `Generated a new Unique ID: ${newId}`);

  const needsSheet = getSheet("Needs");
  if (needsSheet) {
      logEvent("INFO", "testHelperFunctions", null, null, null, `Successfully accessed the "Needs" sheet in Operations DB.`);
  }
  const musicianMasterSheet = getSheet("Musicians_MasterList", musicianDB_ID); // Pass the ID explicitly
   if (musicianMasterSheet) {
      logEvent("INFO", "testHelperFunctions", null, null, null, `Successfully accessed the "Musicians_MasterList" sheet in Musician DB.`);
  }
}

// ==========================================================================
//  SLUT PÅ BLOCK 1
// ==========================================================================
// ==========================================================================
//  BLOCK 2: MUSICIAN DATABASE INTERACTION FUNCTIONS
// ==========================================================================

function getMusicianDbSheetData(sheetName) {
  const cache = CacheService.getScriptCache();
  const cacheKey = `musicianDb_${sheetName}_data_v2`; // Cache versioning if structure changes
  
  const cachedData = cache.get(cacheKey);
  if (cachedData) {
    try {
      return JSON.parse(cachedData);
    } catch (e) {
      Logger.log(`Cache parse error for ${cacheKey}: ${e.message}. Fetching fresh data.`);
      cache.remove(cacheKey); // Remove corrupted cache entry
    }
  }

  const musicianDb = getMusicianDatabaseSpreadsheet();
  if (!musicianDb) return null;

  const sheet = musicianDb.getSheetByName(sheetName);
  if (!sheet) {
    logEvent("ERROR", "getMusicianDbSheetData", null, null, null, `Sheet "${sheetName}" not found in Musician Database.`);
    return null;
  }
  
  const data = sheet.getDataRange().getValues();
  if (data && data.length > 0) {
    try {
      cache.put(cacheKey, JSON.stringify(data), 300); // Cache for 5 minutes
    } catch (e) {
      Logger.log(`Error stringifying or putting data to cache for ${cacheKey}: ${e.message}. Data length: ${data.length}`);
      // Proceed without caching if it fails
    }
  }
  return data;
}


function getMusicianDetails(musicianId) {
  const data = getMusicianDbSheetData("Musicians_MasterList");
  if (!data || data.length < 2) return null;

  const headers = data[0].map(h => String(h).trim()); 
  const musicianIndex = headers.indexOf("MusicianID");
  if (musicianIndex === -1) {
      logEvent("ERROR", "getMusicianDetails", null, null, musicianId, "MusicianID column not found in Musicians_MasterList.");
      return null;
  }
  
  const colMap = {};
  headers.forEach((header, index) => colMap[header] = index);

  for (let i = 1; i < data.length; i++) {
    if (data[i][musicianIndex] === musicianId) {
      const musician = {};
      headers.forEach(header => {
        musician[header] = data[i][colMap[header]];
      });
      return musician;
    }
  }
  logEvent("WARNING", "getMusicianDetails", null, null, musicianId, "Musician not found.");
  return null;
}

function getAllInstruments() {
  const data = getMusicianDbSheetData("Instruments_Definition");
  if (!data || data.length < 2) return null; 

  const instruments = [];
  const headers = data[0].map(h => String(h).trim());
  const colMap = {};
  headers.forEach((header, index) => colMap[header] = index);
  
  const idCol = headers.indexOf("InstrumentID");
  if (idCol === -1) {
      logEvent("ERROR", "getAllInstruments", null, null, null, "InstrumentID column not found in Instruments_Definition.");
      return []; // Return empty if critical column missing
  }


  for (let i = 1; i < data.length; i++) {
    const instrument = {};
    let hasData = false;
    // Ensure the row is not completely empty and has an ID
    if (!data[i][idCol] || String(data[i][idCol]).trim() === "") continue;

    headers.forEach(header => {
      instrument[header] = data[i][colMap[header]];
      if (data[i][colMap[header]] !== "" && data[i][colMap[header]] !== null) hasData = true;
    });
    if(hasData){ 
        instruments.push(instrument);
    }
  }
  return instruments;
}

function getAllQualificationTypes() {
  const data = getMusicianDbSheetData("QualificationTypes_Definition");
  if (!data || data.length < 2) return []; // Return empty array

  const qualificationTypes = [];
  const headers = data[0].map(h => String(h).trim());
  const colMap = {};
  headers.forEach((header, index) => colMap[header] = index);

  const idCol = headers.indexOf("QualificationTypeID");
  if (idCol === -1) {
      logEvent("ERROR", "getAllQualificationTypes", null, null, null, "QualificationTypeID column not found.");
      return [];
  }
  
  for (let i = 1; i < data.length; i++) {
    const qType = {};
    let hasData = false;
    if (!data[i][idCol] || String(data[i][idCol]).trim() === "") continue;

    headers.forEach(header => {
      qType[header] = data[i][colMap[header]];
      if (data[i][colMap[header]] !== "" && data[i][colMap[header]] !== null) hasData = true;
    });
     if(hasData){
        qualificationTypes.push(qType);
    }
  }
  return qualificationTypes;
}

function getInstrumentQualifications(instrumentIdFilter = null) {
  const data = getMusicianDbSheetData("InstrumentQualification_Link");
  if (!data || data.length < 2) return [];

  const instrumentQualifications = [];
  const headers = data[0].map(h => String(h).trim());
  const colMap = {};
  headers.forEach((header, index) => colMap[header] = index);
  const instrumentIdColIndex = headers.indexOf("InstrumentID");
  const iqIdCol = headers.indexOf("InstrumentQualificationID");

   if (iqIdCol === -1) {
       logEvent("ERROR", "getInstrumentQualifications", null, null, null, "InstrumentQualificationID column not found.");
       return [];
   }
   if (instrumentIdColIndex === -1 && instrumentIdFilter) {
      logEvent("ERROR", "getInstrumentQualifications", null, null, null, "InstrumentID column not found for filtering.");
      return [];
  }

  for (let i = 1; i < data.length; i++) {
    if (instrumentIdFilter && instrumentIdColIndex !== -1 && data[i][instrumentIdColIndex] !== instrumentIdFilter) {
      continue; 
    }
    const iq = {};
    let hasData = false;
    if (!data[i][iqIdCol] || String(data[i][iqIdCol]).trim() === "") continue;

     headers.forEach(header => {
      iq[header] = data[i][colMap[header]];
      if (data[i][colMap[header]] !== "" && data[i][colMap[header]] !== null) hasData = true;
    });
    if(hasData){
        instrumentQualifications.push(iq);
    }
  }
  return instrumentQualifications;
}

function getMusicianSpecificQualifications(musicianId) {
  const msqData = getMusicianDbSheetData("MusicianSpecificQualifications_Link");
  const iqData = getMusicianDbSheetData("InstrumentQualification_Link");

  if (!msqData || !iqData || msqData.length < 2 || iqData.length < 2) return [];

  const musicianQualifications = [];
  const msqHeaders = msqData[0].map(h => String(h).trim());
  const msqMusicianIdCol = msqHeaders.indexOf("MusicianID");
  const msqIqIdCol = msqHeaders.indexOf("InstrumentQualificationID");
  
  const iqHeaders = iqData[0].map(h => String(h).trim());
  const iqIdCol = iqHeaders.indexOf("InstrumentQualificationID");

  if (msqMusicianIdCol === -1 || msqIqIdCol === -1 || iqIdCol === -1) {
      logEvent("ERROR", "getMusicianSpecificQualifications", null, musicianId, null, "Required ID columns not found in MSQ_Link or IQ_Link sheets.");
      return [];
  }
  
  const iqMap = {};
  for (let i = 1; i < iqData.length; i++) {
    const iqDetails = {};
    let hasIqData = false;
    if (!iqData[i][iqIdCol] || String(iqData[i][iqIdCol]).trim() === "") continue;
    iqHeaders.forEach((header, index) => {
        iqDetails[header] = iqData[i][index];
        if (iqData[i][index] !== "" && iqData[i][index] !== null) hasIqData = true;
    });
    if(hasIqData){
        iqMap[iqData[i][iqIdCol]] = iqDetails;
    }
  }

  for (let i = 1; i < msqData.length; i++) {
    if (msqData[i][msqMusicianIdCol] === musicianId) {
      const instrumentQualificationID = msqData[i][msqIqIdCol];
      const fullQualificationDetails = iqMap[instrumentQualificationID];
      if (fullQualificationDetails) {
        musicianQualifications.push(fullQualificationDetails);
      } else {
        logEvent("WARNING", "getMusicianSpecificQualifications", null, musicianId, null, `Could not find details for InstrumentQualificationID: ${instrumentQualificationID}`);
      }
    }
  }
  return musicianQualifications;
}

function getAllRankingListDefinitions(instrumentQualificationIdFilter = null) {
  const data = getMusicianDbSheetData("RankingLists_Definition");
  if (!data || data.length < 2) return [];

  const rankingLists = [];
  const headers = data[0].map(h => String(h).trim());
  const colMap = {};
  headers.forEach((header, index) => colMap[header] = index);
  const appliesToIqIdCol = headers.indexOf("AppliesTo_InstrumentQualificationID");
  const rlIdCol = headers.indexOf("RankingListID");

  if (rlIdCol === -1) {
      logEvent("ERROR", "getAllRankingListDefinitions", null,null,null, "RankingListID column not found.");
      return [];
  }
  if (appliesToIqIdCol === -1 && instrumentQualificationIdFilter) {
      logEvent("ERROR", "getAllRankingListDefinitions", null, null, null, "AppliesTo_InstrumentQualificationID column not found for filtering.");
      return [];
  }

  for (let i = 1; i < data.length; i++) {
    if (instrumentQualificationIdFilter && appliesToIqIdCol !== -1 && data[i][appliesToIqIdCol] !== instrumentQualificationIdFilter) {
      continue;
    }
    const rl = {};
    let hasData = false;
    if (!data[i][rlIdCol] || String(data[i][rlIdCol]).trim() === "") continue;
    headers.forEach(header => {
      rl[header] = data[i][colMap[header]];
      if (data[i][colMap[header]] !== "" && data[i][colMap[header]] !== null) hasData = true;
    });
    if(hasData){
        rankingLists.push(rl);
    }
  }
  return rankingLists;
}

function getRankedMusiciansForList(rankingListId) {
  const data = getMusicianDbSheetData("Rankings_Data");
  if (!data || data.length < 2) return []; 

  const rankedMusicians = [];
  const headers = data[0].map(h => String(h).trim());
  const colMap = {};
  headers.forEach((header, index) => colMap[header] = index);
  const rankingListIdCol = headers.indexOf("RankingListID");
  const rankOrderCol = headers.indexOf("RankOrder");
  const musicianIdCol = headers.indexOf("MusicianID");
  const rdIdCol = headers.indexOf("RankingDataID");


  if (rdIdCol === -1 || rankingListIdCol === -1 || rankOrderCol === -1 || musicianIdCol === -1) {
    logEvent("ERROR", "getRankedMusiciansForList", null, null, null, `Required columns not found in Rankings_Data for list ${rankingListId}.`);
    return [];
  }

  for (let i = 1; i < data.length; i++) {
    if (data[i][rankingListIdCol] === rankingListId) {
      const musicianRankData = {};
      let hasData = false;
      if (!data[i][rdIdCol] || String(data[i][rdIdCol]).trim() === "") continue;
       headers.forEach(header => {
         musicianRankData[header] = data[i][colMap[header]];
         if (data[i][colMap[header]] !== "" && data[i][colMap[header]] !== null) hasData = true;
      });
      if(hasData){ 
          rankedMusicians.push(musicianRankData);
      }
    }
  }

  if (rankedMusicians.length === 0) {
    return []; 
  }

  rankedMusicians.sort((a, b) => {
    const rankA = parseInt(a.RankOrder, 10);
    const rankB = parseInt(b.RankOrder, 10);
    if (isNaN(rankA) && isNaN(rankB)) return 0;
    if (isNaN(rankA)) return 1; 
    if (isNaN(rankB)) return -1;
    return rankA - rankB;
  });

  return rankedMusicians;
}


// --- Testfunktioner för Block 2 ---
function testMusicianDbFunctions() {
  Logger.log("--- Starting testMusicianDbFunctions ---");

  const musician1 = getMusicianDetails("MUS-001"); 
  if (musician1) Logger.log(`Musician MUS-001: ${musician1.FirstName} ${musician1.LastName}`);
  else Logger.log("Musician MUS-001 not found or error.");

  const allInstruments = getAllInstruments();
  if (allInstruments) Logger.log(`Found ${allInstruments.length} instruments. First: ${allInstruments[0] ? allInstruments[0].InstrumentName : 'N/A'}`);
  else Logger.log("No instruments found or error.");

  const violinQualifications = getInstrumentQualifications("INST-VLN"); 
  if (violinQualifications) Logger.log(`Found ${violinQualifications.length} qualifications for INST-VLN. First specific role: ${violinQualifications[0] ? violinQualifications[0].SpecificRoleNameForInstrument : 'N/A'}`);
  else Logger.log("No qualifications found for INST-VLN or error.");
  
  const musician1Qualifications = getMusicianSpecificQualifications("MUS-001"); 
  if (musician1Qualifications) {
    Logger.log(`Musician MUS-001 has ${musician1Qualifications.length} specific qualifications.`);
    musician1Qualifications.forEach(q => Logger.log(`  - Role: ${q.SpecificRoleNameForInstrument}`));
  } else Logger.log("No specific qualifications found for MUS-001 or error.");

  const concertmasterLists = getAllRankingListDefinitions("IQ-VLN-TUTTI"); // Using a test IQ_ID
  if (concertmasterLists) Logger.log(`Found ${concertmasterLists.length} ranking lists for IQ-VLN-TUTTI. First list name: ${concertmasterLists[0] ? concertmasterLists[0].RankingListName : 'N/A'}`);
  else Logger.log("No ranking lists for IQ-VLN-TUTTI or error.");

  const rankedViolinists = getRankedMusiciansForList("RL_TEST_SEQ_VLN_TUTTI"); // Using a test RL_ID
  if (rankedViolinists) {
    Logger.log(`Found ${rankedViolinists.length} ranked musicians for RL_TEST_SEQ_VLN_TUTTI.`);
    rankedViolinists.forEach(r => Logger.log(`  - MusicianID: ${r.MusicianID}, Rank: ${r.RankOrder}`));
  } else Logger.log("No ranked musicians for RL_TEST_SEQ_VLN_TUTTI or error.");

  Logger.log("--- Finished testMusicianDbFunctions ---");
  SpreadsheetApp.getUi().alert("Musician DB function tests completed. Check Logs (View > Logs).");
}
// ==========================================================================
//  SLUT PÅ BLOCK 2
// ==========================================================================
// ==========================================================================
//  BLOCK 3: CORE DISPATCH LOGIC
// ==========================================================================

function findNextMusicians(needID) {
  logEvent("INFO", "findNextMusicians", null, needID, null, `Starting search for NeedID: ${needID}`);

  const needsSheet = getSheet("Needs");
  if (!needsSheet) {
      logEvent("ERROR", "findNextMusicians", null, needID, null, "Could not access Needs sheet.");
      return null; 
  }
  const needsData = needsSheet.getDataRange().getValues();
  const needsHeaders = needsData[0].map(h => String(h).trim());
  const needIdColIndexNeeds = needsHeaders.indexOf("NeedID");
  if (needIdColIndexNeeds === -1) {
      logEvent("ERROR", "findNextMusicians", null, needID, null, "NeedID column not found in Needs sheet.");
      return null;
  }

  const needRowOriginalIndex = needsData.slice(1).findIndex(row => row[needIdColIndexNeeds] === needID);

  if (needRowOriginalIndex === -1) {
    logEvent("ERROR", "findNextMusicians", null, needID, null, "NeedID not found in Needs sheet.");
    return null;
  }
  const actualNeedRowIndexInSheet = needRowOriginalIndex + 2; 

  const needRecord = {};
  needsHeaders.forEach((header, index) => needRecord[header] = needsData[needRowOriginalIndex + 1][index]); 

  const projectID = needRecord.ProjectID;
  const rankingListID = needRecord.RankingListID;
  const dispatchType = needRecord.DispatchType;
  const neededQuantity = parseInt(needRecord.NeededQuantity, 10) || 0;
  const maxParallelForFCFS = parseInt(needRecord.MaxParallelDispatches, 10) || 0; 
  const requiresAccomodation = needRecord.RequiresOwnAccomodation === "YES";


  if (!projectID || !rankingListID || !dispatchType || neededQuantity === 0) {
    logEvent("ERROR", "findNextMusicians", projectID, needID, null, "Incomplete need data (ProjectID, RankingListID, DispatchType, or NeededQuantity is missing/zero).");
    return null;
  }

  let rankedMusiciansData = getRankedMusiciansForList(rankingListID); 
  if (!rankedMusiciansData) {
    logEvent("ERROR", "findNextMusicians", projectID, needID, null, `Error fetching ranked musicians for RankingListID: ${rankingListID}. Returning empty array.`);
    return []; 
  }
  if (rankedMusiciansData.length === 0) {
    logEvent("INFO", "findNextMusicians", projectID, needID, null, `RankingListID: ${rankingListID} is empty or returned no musicians.`);
    return [];
  }

  const responseTrackingSheet = getSheet("ResponseTracking");
  if (!responseTrackingSheet) {
      logEvent("ERROR", "findNextMusicians", projectID, needID, null, "Could not access ResponseTracking sheet.");
      return null;
  }
  const rtData = responseTrackingSheet.getDataRange().getValues();
  const rtHeaders = rtData[0].map(h => String(h).trim());
  const rtProjectIDCol = rtHeaders.indexOf("ProjectID");
  const rtNeedIDCol = rtHeaders.indexOf("NeedID");
  const rtMusicianIDCol = rtHeaders.indexOf("MusicianID");
  const rtResponseStatusCol = rtHeaders.indexOf("ResponseStatus");
  
  if ([rtProjectIDCol, rtNeedIDCol, rtMusicianIDCol, rtResponseStatusCol].includes(-1)) {
      logEvent("ERROR", "findNextMusicians", projectID, needID, null, "One or more critical columns missing in ResponseTracking sheet.");
      return null;
  }


  const contactedForThisNeed = new Set();
  const blockedForThisProject = new Set();
  let confirmedYesForThisNeed = 0;
  let waitingForThisNeed = 0;

  for (let i = 1; i < rtData.length; i++) {
    const row = rtData[i];
    const rtMusicianID = row[rtMusicianIDCol];
    if (row[rtNeedIDCol] === needID) {
      contactedForThisNeed.add(rtMusicianID);
      if (row[rtResponseStatusCol] === "Yes") {
        confirmedYesForThisNeed++;
      }
      if (row[rtResponseStatusCol] === "Waiting" || row[rtResponseStatusCol] === "ReminderSent") { // Consider ReminderSent as waiting
        waitingForThisNeed++;
      }
    }
    if (row[rtProjectIDCol] === projectID && (row[rtResponseStatusCol] === "No" || row[rtResponseStatusCol] === "Timeout")) { 
      blockedForThisProject.add(rtMusicianID);
    }
  }
  
  const candidates = [];
  for (const rankedMusicianEntry of rankedMusiciansData) {
    const musicianID = rankedMusicianEntry.MusicianID;

    if (contactedForThisNeed.has(musicianID)) continue;
    if (blockedForThisProject.has(musicianID)) continue;

    const musicianDetails = getMusicianDetails(musicianID); 
    if (!musicianDetails) continue;
    if (musicianDetails.Status !== "Active") continue;
    if (requiresAccomodation && musicianDetails.HasOwnAccomodation !== "YES") continue;

    candidates.push({ 
      MusicianID: musicianID, 
      Email: musicianDetails.Email, 
      FirstName: musicianDetails.FirstName,
      LastName: musicianDetails.LastName 
    });
  }

  if (candidates.length === 0) {
    logEvent("INFO", "findNextMusicians", projectID, needID, null, "No eligible candidates found after filtering.");
     if (confirmedYesForThisNeed >= neededQuantity && needRecord.NeedStatus !== "Filled") {
         const needStatusColIndexNeeds = needsHeaders.indexOf("NeedStatus");
         if (needStatusColIndexNeeds !== -1) {
             needsSheet.getRange(actualNeedRowIndexInSheet, needStatusColIndexNeeds + 1).setValue("Filled");
             logEvent("INFO", "findNextMusicians", projectID, needID, null, "Need status updated to 'Filled' as confirmed quantity met and no more candidates.");
             checkProjectCompletion(projectID);
         }
     }
    return [];
  }

  let musiciansToContact = [];
  const openSlots = neededQuantity - confirmedYesForThisNeed;

  if (openSlots <= 0) {
    logEvent("INFO", "findNextMusicians", projectID, needID, null, "No open slots for this need.");
     const needStatusColIndexNeeds = needsHeaders.indexOf("NeedStatus");
     if (needRecord.NeedStatus !== "Filled" && needStatusColIndexNeeds !== -1) {
         needsSheet.getRange(actualNeedRowIndexInSheet, needStatusColIndexNeeds + 1).setValue("Filled");
         logEvent("INFO", "findNextMusicians", projectID, needID, null, "Need status updated to 'Filled'.");
         checkProjectCompletion(projectID);
     }
    return []; 
  }

  switch (dispatchType) {
    case "Sequential":
      if (waitingForThisNeed === 0 && candidates.length > 0) {
        musiciansToContact = candidates.slice(0, 1);
      }
      break;
    case "Parallel":
      const numToDispatchParallel = Math.min(openSlots - waitingForThisNeed, candidates.length);
      if (numToDispatchParallel > 0) {
        musiciansToContact = candidates.slice(0, numToDispatchParallel);
      }
      break;
    case "FCFS":
      if (waitingForThisNeed === 0 && confirmedYesForThisNeed === 0) { 
          const numToDispatchFCFS = Math.min(maxParallelForFCFS, candidates.length, openSlots * (parseInt(getConfig("FCFS_DispatchMultiplier")) || 3) ); 
          musiciansToContact = candidates.slice(0, numToDispatchFCFS);
      }
      break;
    default:
      logEvent("ERROR", "findNextMusicians", projectID, needID, null, `Unknown DispatchType: ${dispatchType}`);
      return [];
  }
  
  return musiciansToContact;
}


function createFormLink(dispatchID, projectID, needID, musicianEmail) {
  const formBaseUrl = getConfig("GoogleFormBaseURL"); 
  if (!formBaseUrl || formBaseUrl === "YOUR_GOOGLE_FORM_URL_HERE/viewform") { // Check for placeholder too
    logEvent("ERROR", "createFormLink", projectID, needID, null, "GoogleFormBaseURL not found or not configured in Configuration.");
    return "#ERROR_FORM_URL_MISSING";
  }

  const entryDispatchID = getConfig("FormEntryID_DispatchID");
  const entryProjectID = getConfig("FormEntryID_ProjectID");
  const entryNeedID = getConfig("FormEntryID_NeedID");
  const entryMusicianEmail = getConfig("FormEntryID_Email");

  if (!entryDispatchID || entryDispatchID.includes("YOUR_") || 
      !entryProjectID || entryProjectID.includes("YOUR_") || 
      !entryNeedID || entryNeedID.includes("YOUR_") || 
      !entryMusicianEmail || entryMusicianEmail.includes("YOUR_")) {
    logEvent("ERROR", "createFormLink", projectID, needID, null, "One or more Form Entry IDs are missing or not configured in Configuration.");
    return "#ERROR_FORM_ENTRY_ID_MISSING";
  }

  let url = `${formBaseUrl}?usp=pp_url`; 
  url += `&${entryDispatchID}=${encodeURIComponent(dispatchID)}`;
  url += `&${entryProjectID}=${encodeURIComponent(projectID)}`;
  url += `&${entryNeedID}=${encodeURIComponent(needID)}`;
  url += `&${entryMusicianEmail}=${encodeURIComponent(musicianEmail)}`;
  
  return url;
}

function getEmailHtmlContent(templateKey, placeholderObject) {
  let htmlTemplate = getConfig(templateKey);
  if (!htmlTemplate) {
    logEvent("ERROR", "getEmailHtmlContent", placeholderObject.ProjectID, placeholderObject.NeedID, placeholderObject.MusicianID, `Email template not found for key: ${templateKey}`);
    return `<p>Error: Email template ${templateKey} not found.</p><p>Please check Configuration sheet.</p><p>Details: Project ${placeholderObject.ProjectID}, Musician ${placeholderObject.MusicianFirstName}</p>`;
  }

  for (const placeholder in placeholderObject) {
    if (placeholderObject.hasOwnProperty(placeholder)) {
      const regex = new RegExp(`{{${placeholder}}}`, "g");
      htmlTemplate = htmlTemplate.replace(regex, placeholderObject[placeholder] === null || typeof placeholderObject[placeholder] === 'undefined' ? "" : placeholderObject[placeholder]);
    }
  }
  return htmlTemplate;
}

function sendEmailWithOptionalAttachments(recipient, subject, htmlBody, projectID = null) {
  const options = { htmlBody: htmlBody };
  let attachments = [];

  if (projectID) {
    const projectDetails = getProjectDetails(projectID); 

    if (projectDetails && projectDetails.DriveFolderID) {
      try {
        const folder = DriveApp.getFolderById(projectDetails.DriveFolderID);
        const files = folder.getFiles();
        while (files.hasNext()) {
          attachments.push(files.next().getBlob());
        }
        if (attachments.length > 0) {
          options.attachments = attachments;
        }
      } catch (e) {
        logEvent("ERROR", "sendEmailWithOptionalAttachments", projectID, null, null, `Failed to get attachments from Drive folder ID ${projectDetails.DriveFolderID}: ${e.message}`);
      }
    }
  }

  try {
    GmailApp.sendEmail(recipient, subject, "Please enable HTML to view this email.", options);
    logEvent("INFO", "sendEmailWithOptionalAttachments", projectID, null, recipient, `Email sent to ${recipient}. Subject: ${subject}`);
    return true;
  } catch (e) {
    logEvent("ERROR", "sendEmailWithOptionalAttachments", projectID, null, recipient, `Failed to send email to ${recipient}. Subject: ${subject}. Error: ${e.message}`);
    return false;
  }
}

function sendInitialRequests() {
  if (getConfig("SystemPaused") === "YES") {
    logEvent("INFO", "sendInitialRequests", null, null, null, "System is paused. Aborting.");
    return;
  }
  logEvent("INFO", "sendInitialRequests", null, null, null, "Starting initial request processing...");

  const needsSheet = getSheet("Needs");
  if (!needsSheet) {
      logEvent("ERROR", "sendInitialRequests", null, null, null, "Needs sheet not found.");
      return;
  }
  const needsData = needsSheet.getDataRange().getValues();
  const needsHeaders = needsData[0].map(h => String(h).trim());
  
  const projectInfoMap = {};
  const projectInfoSheet = getSheet("ProjectInfo"); 
  if (projectInfoSheet) {
    const projectInfoData = projectInfoSheet.getDataRange().getValues();
    const piHeaders_local = projectInfoData[0].map(h => String(h).trim()); 
    const piIdCol = piHeaders_local.indexOf("ProjectID");
    if (piIdCol !== -1) {
        projectInfoData.slice(1).forEach(row => {
            const proj = {};
            const currentProjectIDInRow = row[piIdCol];
            if(currentProjectIDInRow){ 
                piHeaders_local.forEach((h, idx) => proj[h] = row[idx]); 
                projectInfoMap[currentProjectIDInRow] = proj; 
            }
        });
    } else {
        logEvent("ERROR", "sendInitialRequests", null, null, null, "ProjectID column not found in ProjectInfo. Cannot process needs effectively.");
        return;
    }
  } else {
      logEvent("ERROR", "sendInitialRequests", null, null, null, "ProjectInfo sheet not found. Cannot process needs effectively.");
      return;
  }

  const needIdColNeeds = needsHeaders.indexOf("NeedID");
  const projectIdColNeeds = needsHeaders.indexOf("ProjectID");
  const needStatusColNeeds = needsHeaders.indexOf("NeedStatus");
  const dispatchTypeColNeeds = needsHeaders.indexOf("DispatchType");

  if ([needIdColNeeds,projectIdColNeeds,needStatusColNeeds,dispatchTypeColNeeds].includes(-1)){
      logEvent("ERROR", "sendInitialRequests", null, null, null, "One or more critical columns missing in Needs sheet headers.");
      return;
  }


  for (let i = 1; i < needsData.length; i++) { 
    const currentRow = needsData[i];
    const needID = currentRow[needIdColNeeds];
    const projectID = currentRow[projectIdColNeeds];
    const needStatus = currentRow[needStatusColNeeds];
    const dispatchType = currentRow[dispatchTypeColNeeds];

    if (!needID || !projectID) continue; 
    
    const projectDetails = projectInfoMap[projectID]; 
    if (!projectDetails) {
        continue;
    }
    if (projectDetails.ProjectStatus !== "Active") {
      continue;
    }
    if (needStatus !== "Active") {
      continue;
    }

    const rtSheet = getSheet("ResponseTracking");
    if(!rtSheet){
        logEvent("ERROR", "sendInitialRequests", projectID, needID, null, "ResponseTracking sheet not found. Skipping this need.");
        continue;
    }
    const rtData = rtSheet.getDataRange().getValues();
    const rtHeadersLocal = rtData[0].map(h => String(h).trim()); 
    const rtNeedIDCol = rtHeadersLocal.indexOf("NeedID");
    const rtStatusCol = rtHeadersLocal.indexOf("ResponseStatus");

    if (rtNeedIDCol === -1 || rtStatusCol === -1) {
        logEvent("ERROR", "sendInitialRequests", projectID, needID, null, "NeedID or ResponseStatus column missing in ResponseTracking. Skipping.");
        continue;
    }
    
    let existingWaitingForNeed = 0;
    for(let j=1; j < rtData.length; j++){
        if(rtData[j][rtNeedIDCol] === needID && (rtData[j][rtStatusCol] === "Waiting" || rtData[j][rtStatusCol] === "ReminderSent")){
            existingWaitingForNeed++;
        }
    }

    if (dispatchType === "Sequential" && existingWaitingForNeed > 0) {
        continue;
    }
    if (dispatchType === "FCFS" && existingWaitingForNeed > 0) {
        continue; 
    }

    const musiciansToContact = findNextMusicians(needID); 
    
    if (musiciansToContact && musiciansToContact.length > 0) {
      musiciansToContact.forEach(musician => {
        processSingleDispatchRequest(needID, projectID, musician, projectDetails, dispatchType);
      });
    }
  }
  logEvent("INFO", "sendInitialRequests", null, null, null, "Finished processing initial requests.");
}

function processSingleDispatchRequest(needID, projectID, musician, projectDetails, dispatchType) {
    const dispatchID = generateUniqueId("DISPATCH_");
    const formLink = createFormLink(dispatchID, projectID, needID, musician.Email);

    if(formLink.startsWith("#ERROR")){ 
        logEvent("ERROR", "processSingleDispatchRequest", projectID, needID, musician.MusicianID, `Could not create form link. Aborting dispatch. Error: ${formLink}`);
        return;
    }

    const responseDeadlineHours = parseFloat(projectDetails.ResponseDeadlineHours);
    const sentTimestamp = new Date();
    let deadlineTimestamp = null;
    if (!isNaN(responseDeadlineHours) && responseDeadlineHours > 0) {
        deadlineTimestamp = new Date(sentTimestamp.getTime() + responseDeadlineHours * 60 * 60 * 1000);
    }
    
    const needFullDetails = getNeedDetails(needID); 
    const instrumentName = needFullDetails ? needFullDetails.InstrumentName : "N/A";
    const qualificationName = needFullDetails ? needFullDetails.QualificationName : "N/A";

    const placeholders = {
        MusicianFirstName: musician.FirstName,
        MusicianLastName: musician.LastName,
        ProjectName: projectDetails.ProjectName,
        Instrument: instrumentName,
        Qualification: qualificationName,
        WeekNumber: projectDetails.WeekNumber,
        RehearsalSchedule: projectDetails.RehearsalSchedule,
        ConcertSchedule: projectDetails.ConcertSchedule,
        DeadlineTimestamp: deadlineTimestamp ? deadlineTimestamp.toLocaleString() : "N/A",
        FormLink: formLink,
        ProjectID: projectID, 
        NeedID: needID,
        MusicianID: musician.MusicianID
    };

    const emailHtml = getEmailHtmlContent("MailTemplate_Request", placeholders);
    const emailSubject = `Request: ${projectDetails.ProjectName} - ${instrumentName} (${qualificationName})`;

    const emailSent = sendEmailWithOptionalAttachments(musician.Email, emailSubject, emailHtml, projectID);

    if (emailSent) {
        const rtSheet = getSheet("ResponseTracking");
        if (rtSheet) {
            rtSheet.appendRow([
                dispatchID, needID, projectID, musician.MusicianID, musician.Email,
                "Waiting", sentTimestamp, deadlineTimestamp, 
                null, null, null, formLink, null 
            ]);
            logEvent("DISPATCH", "processSingleDispatchRequest", projectID, needID, musician.MusicianID, `Request sent. DispatchID: ${dispatchID}`);
        } else {
            logEvent("ERROR", "processSingleDispatchRequest", projectID, needID, musician.MusicianID, `Email sent, but ResponseTracking NOT FOUND. DispatchID: ${dispatchID}!`);
        }
    } else {
        logEvent("ERROR", "processSingleDispatchRequest", projectID, needID, musician.MusicianID, `Failed to send request email. DispatchID: ${dispatchID}`);
    }
}

function processNextStepForBehov(needID) {
  if (getConfig("SystemPaused") === "YES") {
    logEvent("INFO", "processNextStepForBehov", null, needID, null, "System is paused. Aborting.");
    return;
  }

  const needDetails = getNeedDetails(needID); 
  if (!needDetails) {
    logEvent("ERROR", "processNextStepForBehov", null, needID, null, "NeedID not found or error fetching details.");
    return;
  }
  
  const projectID = needDetails.ProjectID;
  const dispatchType = needDetails.DispatchType;
  const needStatus = needDetails.NeedStatus;

  const projectDetails = getProjectDetails(projectID); 
  if (!projectDetails) {
    logEvent("ERROR", "processNextStepForBehov", projectID, needID, null, "Could not retrieve project details.");
    return;
  }

  if (projectDetails.ProjectStatus !== "Active") return;
  if (needStatus !== "Active") return;

  if (dispatchType === "Sequential" || dispatchType === "Parallel") {
    const musiciansToContact = findNextMusicians(needID); 
    if (musiciansToContact && musiciansToContact.length > 0) {
      musiciansToContact.forEach(musician => {
         processSingleDispatchRequest(needID, projectID, musician, projectDetails, dispatchType);
      });
    } else {
      const updatedNeedDetails = getNeedDetails(needID); 
      if (updatedNeedDetails && updatedNeedDetails.NeedStatus === "Filled") {
          checkProjectCompletion(projectID);
      }
    }
  } else if (dispatchType === "FCFS") {
    checkFCFSBatchCompletion(needID); 
  }
}

function sendInitialRequests_MENU() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert("Confirm", "Do you want to send initial requests for all active needs?", ui.ButtonSet.YES_NO);
  if (response == ui.Button.YES) {
    logEvent("INFO", "sendInitialRequests_MENU", null, null, null, "Manual execution started by admin.");
    sendInitialRequests();
    ui.alert("Initial requests have been processed. Check EventLog.");
  }
}

function testDispatchLogic() {
  Logger.log("--- Starting testDispatchLogic ---");
  // Mock necessary data or use test setup functions
  // setupTestData_SequentialScenario(); // Example
  SpreadsheetApp.flush();
  sendInitialRequests(); 
  Logger.log("--- Finished testDispatchLogic. Check EventLog, ResponseTracking, and your AdminEmail. ---");
  SpreadsheetApp.getUi().alert("Dispatch logic test (sendInitialRequests) executed. Check EventLog, ResponseTracking.");
}

// ==========================================================================
//  SLUT PÅ BLOCK 3
// ==========================================================================
// ==========================================================================
//  BLOCK 4: RESPONSE HANDLING, REMINDERS, DEADLINES, COMPLETION
// ==========================================================================

function handleFormResponseTrigger(e) {
  if (!e || !e.namedValues) {
    logEvent("ERROR", "handleFormResponseTrigger", null, null, null, "Event object (e) or e.namedValues is missing.");
    return;
  }
  handleFormResponse(e); 
}

function handleFormResponse(e) {
  logEvent("INFO", "handleFormResponse", null, null, null, `Form response received: ${JSON.stringify(e.namedValues)}`);

  if (getConfig("SystemPaused") === "YES") {
    logEvent("INFO", "handleFormResponse", null, null, null, "System is paused. Response logged but no further action taken now.");
    return;
  }

  const responseValueRaw = e.namedValues[getConfig("FormQuestion_Response") || "Svar"];
  const responseValue = responseValueRaw ? responseValueRaw[0].trim().toLowerCase() : null;
  
  const dispatchIdFormFieldName = getConfig("FormQuestion_DispatchID_FieldName") || "DispatchID (DO NOT EDIT)";
  const dispatchIDRaw = e.namedValues[dispatchIdFormFieldName];
  const dispatchID = dispatchIDRaw ? dispatchIDRaw[0] : null;

  if (!dispatchID || !responseValue) {
    logEvent("ERROR", "handleFormResponse", null, null, null, `Missing DispatchID ('${dispatchID}') or Response Value ('${responseValue}') from form.`);
    return;
  }

  const rtSheet = getSheet("ResponseTracking");
  if (!rtSheet) {
      logEvent("CRITICAL ERROR", "handleFormResponse", null, null, dispatchID, "ResponseTracking sheet not found.");
      return;
  }
  const rtData = rtSheet.getDataRange().getValues();
  const rtHeaders = rtData[0].map(h => String(h).trim());
  const dispatchIdCol = rtHeaders.indexOf("DispatchID");
  const responseStatusCol = rtHeaders.indexOf("ResponseStatus");
  const responseTimestampCol = rtHeaders.indexOf("ResponseTimestamp");
  const ackSentTimestampCol = rtHeaders.indexOf("AcknowledgementSentTimestamp");
  const needIdCol = rtHeaders.indexOf("NeedID");
  const projectIdCol = rtHeaders.indexOf("ProjectID");
  const musicianIdCol = rtHeaders.indexOf("MusicianID");
  const musicianEmailCol = rtHeaders.indexOf("MusicianEmail");
  const adminNotifiedResponseCol = rtHeaders.indexOf("AdminNotified_MusicianResponse");


  if ([dispatchIdCol,responseStatusCol,responseTimestampCol,ackSentTimestampCol,needIdCol,projectIdCol,musicianIdCol,musicianEmailCol].includes(-1)){
      logEvent("CRITICAL ERROR", "handleFormResponse", null, null, dispatchID, "One or more critical columns missing in ResponseTracking sheet headers.");
      return;
  }

  let foundRowIndex = -1;
  for (let i = 1; i < rtData.length; i++) {
    if (rtData[i][dispatchIdCol] === dispatchID) { 
      foundRowIndex = i + 1; 
      break;
    }
  }

  if (foundRowIndex === -1) {
    logEvent("WARNING", "handleFormResponse", null, null, null, `No dispatch found for DispatchID: ${dispatchID}. Might be an old or invalid link.`);
    return;
  }
  
  const originalStatus = rtData[foundRowIndex - 1][responseStatusCol];
  if (originalStatus !== "Waiting" && originalStatus !== "ReminderSent") { 
      logEvent("INFO", "handleFormResponse", rtData[foundRowIndex - 1][projectIdCol], rtData[foundRowIndex - 1][needIdCol], rtData[foundRowIndex - 1][musicianIdCol], `Response received for DispatchID ${dispatchID} which is already '${originalStatus}'. Processing as a late response if applicable (e.g. FCFS).`);
  }


  const currentResponseRow = rtData[foundRowIndex -1]; 
  const needID = currentResponseRow[needIdCol];
  const projectID = currentResponseRow[projectIdCol];
  const musicianID = currentResponseRow[musicianIdCol];
  const musicianEmail = currentResponseRow[musicianEmailCol];

  const projectDetails = getProjectDetails(projectID); 
  const needDetails = getNeedDetails(needID);       

  if (!projectDetails || !needDetails) {
      logEvent("ERROR", "handleFormResponse", projectID, needID, musicianID, "Could not retrieve project or need details. Aborting response processing.");
      return;
  }
  
  const responseTimestamp = new Date();
  let finalStatusToSet = responseValue === "yes" ? "Yes" : "No";
  rtSheet.getRange(foundRowIndex, responseTimestampCol + 1).setValue(responseTimestamp);

  if (projectDetails.ProjectStatus === "Paused" || needDetails.NeedStatus === "Paused") {
    rtSheet.getRange(foundRowIndex, responseStatusCol + 1).setValue(finalStatusToSet + "_PausedItem");
    logEvent("INFO", "handleFormResponse", projectID, needID, musicianID, `Response received for a paused project/need. Logging response. Admin will be notified.`);
    const adminEmailVal = getConfig("AdminEmail");
    if (adminEmailVal && (getConfig("NotifyAdmin_OnMusicianResponse_Yes") === "YES" || getConfig("NotifyAdmin_OnMusicianResponse_No") === "YES")) { 
        const musicianDetailsResponse = getMusicianDetails(musicianID); // Renamed to avoid conflict
        const adminSubject = `Response on Paused Item: ${projectDetails.ProjectName}`;
        const adminHtml = getEmailHtmlContent("MailTemplate_Admin_Response_On_Paused_Item", {
            ProjectName: projectDetails.ProjectName,
            Instrument: needDetails.InstrumentName, 
            Qualification: needDetails.QualificationName,
            MusicianName: musicianDetailsResponse ? `${musicianDetailsResponse.FirstName} ${musicianDetailsResponse.LastName}` : musicianEmail,
            Response: responseValue.toUpperCase()
        });
        sendEmailWithOptionalAttachments(adminEmailVal, adminSubject, adminHtml);
         if(adminNotifiedResponseCol !== -1 && adminNotifiedResponseCol < rtHeaders.length) rtSheet.getRange(foundRowIndex, adminNotifiedResponseCol + 1).setValue(new Date());
    }
    return; 
  }


  if (responseValue === "yes") {
    let lock = LockService.getScriptLock();
    let locked = false;
    try {
      locked = lock.tryLock(20000); 
      if (!locked) {
        logEvent("ERROR", "handleFormResponse", projectID, needID, musicianID, "Could not obtain lock to process YES response. Response not saved as final YES.");
        return;
      }

      const freshNeedDetails = getNeedDetails(needID); 
      const freshRtData = rtSheet.getDataRange().getValues(); 
      const currentYesCount = countCurrentYesForNeed(needID, freshRtData); 

      let ackTemplateKey = "";
      let needJustFilled = false;

      if (currentYesCount >= freshNeedDetails.NeededQuantity && freshNeedDetails.NeedStatus === "Filled") {
          finalStatusToSet = "Declined_AlreadyFilled";
          ackTemplateKey = "MailTemplate_Acknowledgement_AlreadyFilled";
          logEvent("INFO", "handleFormResponse", projectID, needID, musicianID, "YES response, but need already filled. Marked as Declined_AlreadyFilled.");
      } else if (currentYesCount < freshNeedDetails.NeededQuantity) {
          finalStatusToSet = "Yes";
          ackTemplateKey = "MailTemplate_Acknowledgement_Yes";
          logEvent("INFO", "handleFormResponse", projectID, needID, musicianID, "YES response accepted.");
          if ((currentYesCount + 1) >= freshNeedDetails.NeededQuantity && freshNeedDetails.NeedStatus !== "Filled") {
              const needsSheetRef = getSheet("Needs"); 
              const needsSheetData = needsSheetRef.getDataRange().getValues();
              const needsSheetHeaders = needsSheetData[0].map(h => String(h).trim());
              const needsStatusColIdx = needsSheetHeaders.indexOf("NeedStatus");
              const needRowIdx = needsSheetData.slice(1).findIndex(r => r[needsSheetHeaders.indexOf("NeedID")] === needID) + 2;
              if (needsStatusColIdx !== -1 && needRowIdx > 1) {
                  needsSheetRef.getRange(needRowIdx, needsStatusColIdx + 1).setValue("Filled");
                  needsSheetRef.getRange(needRowIdx, needsSheetHeaders.indexOf("LastModified")+1).setValue(new Date());
                  logEvent("INFO", "handleFormResponse", projectID, needID, null, `Need ${needID} status updated to 'Filled'.`);
                  needJustFilled = true;
              }
          }
      } else { 
          finalStatusToSet = "Yes"; 
          ackTemplateKey = "MailTemplate_Acknowledgement_Yes";
          logEvent("INFO", "handleFormResponse", projectID, needID, musicianID, "YES response accepted (FCFS scenario or similar).");
          if ((currentYesCount + 1) >= freshNeedDetails.NeededQuantity && freshNeedDetails.NeedStatus !== "Filled") {
              const needsSheetRef = getSheet("Needs"); 
              const needsSheetData = needsSheetRef.getDataRange().getValues();
              const needsSheetHeaders = needsSheetData[0].map(h => String(h).trim());
              const needsStatusColIdx = needsSheetHeaders.indexOf("NeedStatus");
              const needRowIdx = needsSheetData.slice(1).findIndex(r => r[needsSheetHeaders.indexOf("NeedID")] === needID) + 2;
              if (needsStatusColIdx !== -1 && needRowIdx > 1) {
                  needsSheetRef.getRange(needRowIdx, needsStatusColIdx + 1).setValue("Filled");
                  needsSheetRef.getRange(needRowIdx, needsSheetHeaders.indexOf("LastModified")+1).setValue(new Date());
                  logEvent("INFO", "handleFormResponse", projectID, needID, null, `Need ${needID} status updated to 'Filled' by this FCFS YES.`);
                  needJustFilled = true;
              }
          }
      }
      
      rtSheet.getRange(foundRowIndex, responseStatusCol + 1).setValue(finalStatusToSet); 
      
      const musicianDetailsAck = getMusicianDetails(musicianID); // Renamed
      const ackPlaceholders = {
          MusicianFirstName: musicianDetailsAck ? musicianDetailsAck.FirstName : "Musician",
          ProjectName: projectDetails.ProjectName,
          Instrument: freshNeedDetails.InstrumentName,
          Qualification: freshNeedDetails.QualificationName,
          ProjectID: projectID, NeedID: needID, MusicianID: musicianID 
      };
      const ackHtml = getEmailHtmlContent(ackTemplateKey, ackPlaceholders);
      const ackSubject = ackTemplateKey === "MailTemplate_Acknowledgement_Yes" ? `Confirmation: ${projectDetails.ProjectName}` : `Regarding: ${projectDetails.ProjectName}`;
      sendEmailWithOptionalAttachments(musicianEmail, ackSubject, ackHtml, projectID);
      rtSheet.getRange(foundRowIndex, ackSentTimestampCol + 1).setValue(new Date());

      const adminEmailVal = getConfig("AdminEmail");
      if (finalStatusToSet === "Yes" && adminEmailVal && getConfig("NotifyAdmin_OnMusicianResponse_Yes") === "YES") {
          const adminSubjectYes = `Musician Responded YES: ${projectDetails.ProjectName}`; // Renamed
          const adminHtmlYes = getEmailHtmlContent("MailTemplate_Admin_MusicianResponded", { // Renamed
              ProjectName: projectDetails.ProjectName, Instrument: freshNeedDetails.InstrumentName, Qualification: freshNeedDetails.QualificationName,
              MusicianName: musicianDetailsAck ? `${musicianDetailsAck.FirstName} ${musicianDetailsAck.LastName}` : musicianEmail, Response: "YES"
          });
          sendEmailWithOptionalAttachments(adminEmailVal, adminSubjectYes, adminHtmlYes);
          if(adminNotifiedResponseCol !== -1 && adminNotifiedResponseCol < rtHeaders.length) rtSheet.getRange(foundRowIndex, adminNotifiedResponseCol + 1).setValue(new Date());
      }

      if (needJustFilled && adminEmailVal && getConfig("NotifyAdmin_OnNeedFilled") === "YES") {
         const needsSheetForNotify = getSheet("Needs");
         const nHeaders = needsSheetForNotify.getDataRange().getValues()[0].map(h => String(h).trim());
         const adminNotifiedColNeeds = nHeaders.indexOf("AdminNotified_FilledTimestamp");
         const needRowIdxNeeds = getNeedRowIndex(needID); 
         if(adminNotifiedColNeeds !== -1 && needRowIdxNeeds !== -1 ){
            const currentNotifiedVal = needsSheetForNotify.getRange(needRowIdxNeeds + 1, adminNotifiedColNeeds + 1).getValue();
            if (!currentNotifiedVal) { // Only send if not already notified
                const adminSubjectN = `Need Filled: ${projectDetails.ProjectName} - ${freshNeedDetails.InstrumentName}`;
                const adminHtmlN = getEmailHtmlContent("MailTemplate_Admin_NeedFilled", { ProjectName: projectDetails.ProjectName, Instrument: freshNeedDetails.InstrumentName, Qualification: freshNeedDetails.QualificationName });
                sendEmailWithOptionalAttachments(adminEmailVal, adminSubjectN, adminHtmlN);
                needsSheetForNotify.getRange(needRowIdxNeeds + 1, adminNotifiedColNeeds + 1).setValue(new Date());
            }
         }
      }
      
      if (needJustFilled) {
          checkProjectCompletion(projectID);
      }

    } catch (err) {
      logEvent("ERROR", "handleFormResponse", projectID, needID, musicianID, `Error processing YES response with lock: ${err.message} ${err.stack}`);
    } finally {
      if (locked) {
        lock.releaseLock();
      }
    }
  } 
  else if (responseValue === "no") {
    rtSheet.getRange(foundRowIndex, responseStatusCol + 1).setValue("No");
    logEvent("INFO", "handleFormResponse", projectID, needID, musicianID, "NO response processed.");
    
    const adminEmailVal = getConfig("AdminEmail");
    if (adminEmailVal && getConfig("NotifyAdmin_OnMusicianResponse_No") === "YES") {
        const musicianDetailsNo = getMusicianDetails(musicianID); // Renamed
        const adminSubjectNo = `Musician Responded NO: ${projectDetails.ProjectName}`; // Renamed
        const adminHtmlNo = getEmailHtmlContent("MailTemplate_Admin_MusicianResponded", { // Renamed
            ProjectName: projectDetails.ProjectName, Instrument: needDetails.InstrumentName, Qualification: needDetails.QualificationName,
            MusicianName: musicianDetailsNo ? `${musicianDetailsNo.FirstName} ${musicianDetailsNo.LastName}` : musicianEmail, Response: "NO"
        });
        sendEmailWithOptionalAttachments(adminEmailVal, adminSubjectNo, adminHtmlNo);
        if(adminNotifiedResponseCol !== -1 && adminNotifiedResponseCol < rtHeaders.length) rtSheet.getRange(foundRowIndex, adminNotifiedResponseCol + 1).setValue(new Date());
    }

    if (needDetails.DispatchType === "Sequential" || needDetails.DispatchType === "Parallel") {
      processNextStepForBehov(needID);
    }
    else if (needDetails.DispatchType === "FCFS") {
      checkFCFSBatchCompletion(needID);
    }
  }

  logEvent("INFO", "handleFormResponse", projectID, needID, musicianID, "Finished processing form response.");
}


function checkFCFSBatchCompletion(needID) {
    const needDetails = getNeedDetails(needID); 
    if (!needDetails || needDetails.DispatchType !== "FCFS" || needDetails.NeedStatus === "Filled") return;

    const rtSheet = getSheet("ResponseTracking");
    if (!rtSheet) return;
    const rtData = rtSheet.getDataRange().getValues();
    const rtHeaders = rtData[0].map(h => String(h).trim());
    const rtNeedIDCol = rtHeaders.indexOf("NeedID");
    const rtStatusCol = rtHeaders.indexOf("ResponseStatus");

    let dispatchedInThisBatch = 0; 
    let respondedInThisBatch = 0; 

    for(let i=1; i < rtData.length; i++){
        if(rtData[i][rtNeedIDCol] === needID){
            const status = rtData[i][rtStatusCol];
            if(status === "Waiting" || status === "ReminderSent"){
                dispatchedInThisBatch++;
            } else if (status === "Yes" || status === "No" || status === "Timeout" || status === "Declined_AlreadyFilled") {
                respondedInThisBatch++;
            }
        }
    }
    
    if (dispatchedInThisBatch === 0 && respondedInThisBatch > 0) { 
        logEvent("INFO", "checkFCFSBatchCompletion", needDetails.ProjectID, needID, null, `FCFS Batch for Need ${needID} appears complete. No more 'Waiting' dispatches.`);
        
        const currentYesCount = countCurrentYesForNeed(needID, rtData);
        if (currentYesCount < needDetails.NeededQuantity) {
            logEvent("WARNING", "checkFCFSBatchCompletion", needDetails.ProjectID, needID, null, `FCFS Batch for Need ${needID} is complete, but need is NOT filled (${currentYesCount}/${needDetails.NeededQuantity}). Notifying admin.`);
            
            const adminEmailVal = getConfig("AdminEmail");
            if (adminEmailVal) {
                const projectDetails = getProjectDetails(needDetails.ProjectID);
                const adminSubject = `Action Required: FCFS Batch Incomplete - ${projectDetails.ProjectName}`;
                const adminHtml = getEmailHtmlContent("MailTemplate_Admin_FCFS_Batch_Incomplete", {
                    ProjectName: projectDetails.ProjectName,
                    Instrument: needDetails.InstrumentName,
                    Qualification: needDetails.QualificationName,
                    NeededQuantity: needDetails.NeededQuantity,
                    ConfirmedCount: currentYesCount,
                    NeedID: needID, ProjectID: projectDetails.ProjectID
                });
                sendEmailWithOptionalAttachments(adminEmailVal, adminSubject, adminHtml);
            }
        } else {
            logEvent("INFO", "checkFCFSBatchCompletion", needDetails.ProjectID, needID, null, `FCFS Batch for Need ${needID} is complete, and need is filled.`);
        }
    } else {
      logEvent("DEBUG","checkFCFSBatchCompletion", needDetails.ProjectID, needID, null, `FCFS Batch for Need ${needID} not yet complete. Still waiting on ${dispatchedInThisBatch} dispatches.`);
    }
}


function checkReminders() {
  if (getConfig("SystemPaused") === "YES") return;
  logEvent("INFO", "checkReminders", null, null, null, "Starting reminder check...");

  const rtSheet = getSheet("ResponseTracking");
  if (!rtSheet) return;
  const rtData = rtSheet.getDataRange().getValues();
  const rtHeaders = rtData[0].map(h => String(h).trim());
  const statusCol = rtHeaders.indexOf("ResponseStatus");
  const sentTimeCol = rtHeaders.indexOf("SentTimestamp");
  const deadlineTimeCol = rtHeaders.indexOf("DeadlineTimestamp");
  const reminderSentCol = rtHeaders.indexOf("ReminderSentTimestamp");
  const projectIDCol = rtHeaders.indexOf("ProjectID");
  const needIDCol = rtHeaders.indexOf("NeedID");
  const musicianIDCol = rtHeaders.indexOf("MusicianID");
  const musicianEmailCol = rtHeaders.indexOf("MusicianEmail");
  const formLinkCol = rtHeaders.indexOf("FormLink");
  
  if ([statusCol,sentTimeCol,deadlineTimeCol,reminderSentCol,projectIDCol,needIDCol,musicianIDCol,musicianEmailCol, formLinkCol].includes(-1)){
      logEvent("ERROR", "checkReminders", null, null, null, "One or more critical columns missing in ResponseTracking for reminders.");
      return;
  }

  const reminderPercentage = parseFloat(getConfig("ReminderPercentage"));
  if (isNaN(reminderPercentage) || reminderPercentage <= 0 || reminderPercentage >= 100) {
    logEvent("WARNING", "checkReminders", null, null, null, `Invalid ReminderPercentage: ${getConfig("ReminderPercentage")}. Reminders will not be sent.`);
    return;
  }

  const now = new Date().getTime();

  for (let i = 1; i < rtData.length; i++) {
    const row = rtData[i];
    if (row[statusCol] === "Waiting" && !row[reminderSentCol]) { 
      const sentTimestampVal = row[sentTimeCol];
      const deadlineTimestampValue = row[deadlineTimeCol];
      
      if (!sentTimestampVal || !deadlineTimestampValue) continue;
      
      const sentTimestamp = new Date(sentTimestampVal).getTime();
      const deadlineTimestamp = new Date(deadlineTimestampValue).getTime();
      if (now > deadlineTimestamp) continue; 

      const projectDetails = getProjectDetails(row[projectIDCol]);
      const needDetails = getNeedDetails(row[needIDCol]);
      if (!projectDetails || projectDetails.ProjectStatus !== "Active" || !needDetails || needDetails.NeedStatus !== "Active") {
        continue;
      }

      const totalDuration = deadlineTimestamp - sentTimestamp;
      if (totalDuration <=0) continue;

      const reminderThresholdTime = sentTimestamp + (totalDuration * (reminderPercentage / 100));

      if (now >= reminderThresholdTime) {
        const musicianDetailsRem = getMusicianDetails(row[musicianIDCol]); // Renamed
        const placeholders = {
          MusicianFirstName: musicianDetailsRem ? musicianDetailsRem.FirstName : "Musician",
          ProjectName: projectDetails.ProjectName,
          Instrument: needDetails.InstrumentName,
          Qualification: needDetails.QualificationName,
          DeadlineTimestamp: new Date(deadlineTimestampValue).toLocaleString(),
          FormLink: row[formLinkCol], 
          ProjectID: row[projectIDCol], NeedID: row[needIDCol], MusicianID: row[musicianIDCol]
        };
        const emailHtml = getEmailHtmlContent("MailTemplate_Reminder", placeholders);
        const emailSubject = `Reminder: Request for ${projectDetails.ProjectName}`;
        
        if(sendEmailWithOptionalAttachments(row[musicianEmailCol], emailSubject, emailHtml, row[projectIDCol])){
            rtSheet.getRange(i + 1, reminderSentCol + 1).setValue(new Date());
            rtSheet.getRange(i+1, statusCol + 1).setValue("ReminderSent"); 
            logEvent("REMINDER", "checkReminders", row[projectIDCol], row[needIDCol], row[musicianIDCol], `Reminder sent. Status updated.`);
        }
      }
    }
  }
  logEvent("INFO", "checkReminders", null, null, null, "Finished reminder check.");
}

function checkDeadlines() {
  if (getConfig("SystemPaused") === "YES") return;
  logEvent("INFO", "checkDeadlines", null, null, null, "Starting deadline check...");

  const rtSheet = getSheet("ResponseTracking");
  if (!rtSheet) return;
  const rtData = rtSheet.getDataRange().getValues();
  const rtHeaders = rtData[0].map(h => String(h).trim());
  const statusCol = rtHeaders.indexOf("ResponseStatus");
  const deadlineTimeCol = rtHeaders.indexOf("DeadlineTimestamp");
  const projectIDCol = rtHeaders.indexOf("ProjectID");
  const needIDCol = rtHeaders.indexOf("NeedID");
  const musicianIDCol = rtHeaders.indexOf("MusicianID");
  const responseTimestampCol = rtHeaders.indexOf("ResponseTimestamp");


  if ([statusCol,deadlineTimeCol,projectIDCol,needIDCol,musicianIDCol,responseTimestampCol].includes(-1)){
      logEvent("ERROR", "checkDeadlines", null, null, null, "One or more critical columns missing in ResponseTracking for deadlines.");
      return;
  }

  const now = new Date();

  for (let i = 1; i < rtData.length; i++) {
    const row = rtData[i];
    const deadlineTimestampValue = row[deadlineTimeCol];

    if ((row[statusCol] === "Waiting" || row[statusCol] === "ReminderSent") && deadlineTimestampValue && new Date(deadlineTimestampValue) < now) {
      const projectID = row[projectIDCol];
      const needID = row[needIDCol];
      const musicianID = row[musicianIDCol];

      const projectDetails = getProjectDetails(projectID);
      const needDetails = getNeedDetails(needID);
      if (!projectDetails || projectDetails.ProjectStatus !== "Active" || !needDetails || needDetails.NeedStatus !== "Active") {
        continue;
      }
      
      rtSheet.getRange(i + 1, statusCol + 1).setValue("Timeout");
      rtSheet.getRange(i + 1, responseTimestampCol + 1).setValue(now); 
      logEvent("DEADLINE", "checkDeadlines", projectID, needID, musicianID, `Response timed out. Marked as Timeout.`);

      if (needDetails.DispatchType === "Sequential" || needDetails.DispatchType === "Parallel") {
        processNextStepForBehov(needID);
      } 
      else if (needDetails.DispatchType === "FCFS") {
        checkFCFSBatchCompletion(needID);
      }
    }
  }
  logEvent("INFO", "checkDeadlines", null, null, null, "Finished deadline check.");
}


function checkProjectCompletion(projectIDOrEvent = null) {
  let projectIDToForceCheck = null;
  let triggerInfo = "";

  if (projectIDOrEvent && typeof projectIDOrEvent === 'string') {
    projectIDToForceCheck = projectIDOrEvent;
  } else if (projectIDOrEvent && typeof projectIDOrEvent === 'object' && projectIDOrEvent.triggerUid) {
    triggerInfo = ` (Trigger UID: ${projectIDOrEvent.triggerUid})`;
  } else if (projectIDOrEvent) {
    logEvent("WARNING", "checkProjectCompletion", null, null, null, `Unexpected param: ${typeof projectIDOrEvent}.${triggerInfo}`);
  }

  if (getConfig("SystemPaused") === "YES" && !projectIDToForceCheck) { 
    return;
  }
  logEvent("INFO", "checkProjectCompletion", projectIDToForceCheck, null, null, `Starting project completion check.${projectIDToForceCheck ? " Forced: " + projectIDToForceCheck : " General."}${triggerInfo}`);

  const projectInfoSheet = getSheet("ProjectInfo");
  const needsSheet = getSheet("Needs");
  if (!projectInfoSheet || !needsSheet) {
    logEvent("ERROR", "checkProjectCompletion", projectIDToForceCheck, null, null, "ProjectInfo or Needs sheet not found.");
    return;
  }

  const projectData = projectInfoSheet.getDataRange().getValues();
  const piHeaders = projectData[0].map(h => String(h).trim());
  const projIdCol = piHeaders.indexOf("ProjectID");
  const projStatusCol = piHeaders.indexOf("ProjectStatus");
  const projNameCol = piHeaders.indexOf("ProjectName");
  const piLastModCol = piHeaders.indexOf("LastModified");


  const needsData = needsSheet.getDataRange().getValues();
  const nHeaders = needsData[0].map(h => String(h).trim());
  const nProjIdCol = nHeaders.indexOf("ProjectID");
  const nNeedStatusCol = nHeaders.indexOf("NeedStatus");

  if ([projIdCol,projStatusCol,projNameCol,piLastModCol,nProjIdCol,nNeedStatusCol].includes(-1)){
    logEvent("ERROR", "checkProjectCompletion", projectIDToForceCheck, null, null, "Critical columns missing in ProjectInfo/Needs for completion check.");
    return;
  }

  const projectsToCheck = [];
  if (projectIDToForceCheck) {
    const forcedProjectExists = projectData.slice(1).some(row => row[projIdCol] === projectIDToForceCheck);
    if (forcedProjectExists) {
      projectsToCheck.push(projectIDToForceCheck);
    } else {
      if (projectsToCheck.length === 0) return;
    }
  } else {
    projectData.slice(1).forEach(row => {
      if (row[projIdCol] && row[projStatusCol] === "Active") { 
        projectsToCheck.push(row[projIdCol]);
      }
    });
  }

  if (projectsToCheck.length === 0 && !projectIDToForceCheck) {
      return;
  }

  for (const currentProjectID of projectsToCheck) {
    const projectRowArray = projectData.slice(1).find(r => r[projIdCol] === currentProjectID);
    if (!projectRowArray) continue;
    
    if (projectRowArray[projStatusCol] === "Completed" && !projectIDToForceCheck) {
        continue;
    }

    let allNeedsFilled = true;
    let projectHasNeeds = false;
    for (let i = 1; i < needsData.length; i++) {
      if (needsData[i][nProjIdCol] === currentProjectID) {
        projectHasNeeds = true;
        if (needsData[i][nNeedStatusCol] !== "Filled") {
          allNeedsFilled = false;
          break; 
        }
      }
    }

    if (projectHasNeeds && allNeedsFilled && projectRowArray[projStatusCol] !== "Completed") {
      const projectRowSheetIndex = projectData.slice(1).findIndex(r => r[projIdCol] === currentProjectID) + 2; 
      projectInfoSheet.getRange(projectRowSheetIndex, projStatusCol + 1).setValue("Completed");
      projectInfoSheet.getRange(projectRowSheetIndex, piLastModCol + 1).setValue(new Date());
      logEvent("INFO", "checkProjectCompletion", currentProjectID, null, null, `Project ${currentProjectID} marked 'Completed'.`);

      const adminEmailVal = getConfig("AdminEmail");
      if (adminEmailVal) {
          const projectName = projectRowArray[projNameCol];
          const adminSubject = `Project Completed: ${projectName}`;
          
          let confirmedMusiciansReport = "Confirmed Musicians:\n";
          const rtSheet = getSheet("ResponseTracking");
          if (rtSheet) {
              const rtSheetData = rtSheet.getDataRange().getValues(); 
              const rtSheetHeaders = rtSheetData[0].map(h => String(h).trim()); 
              const rtProjIdCol = rtSheetHeaders.indexOf("ProjectID");
              const rtNeedIdCol = rtSheetHeaders.indexOf("NeedID");
              const rtMusicianIdCol = rtSheetHeaders.indexOf("MusicianID");
              const rtStatusCol = rtSheetHeaders.indexOf("ResponseStatus");

              rtSheetData.slice(1).forEach(rtRow => {
                  if (rtRow[rtProjIdCol] === currentProjectID && rtRow[rtStatusCol] === "Yes") {
                      const musicianDetailsComp = getMusicianDetails(rtRow[rtMusicianIdCol]); // Renamed
                      const needDetailsForReport = getNeedDetails(rtRow[rtNeedIdCol]);
                      confirmedMusiciansReport += `- ${musicianDetailsComp ? musicianDetailsComp.FirstName + " " + musicianDetailsComp.LastName : rtRow[rtMusicianIdCol] } for ${needDetailsForReport ? needDetailsForReport.InstrumentName + " (" + needDetailsForReport.QualificationName + ")" : rtRow[rtNeedIdCol]}\n`;
                  }
              });
          } else {
              confirmedMusiciansReport += "Could not retrieve response tracking data for detailed report.\n";
          }

          const adminHtml = getEmailHtmlContent("MailTemplate_Admin_ProjectCompleted", {
            ProjectName: projectName,
            CompletionDate: new Date().toLocaleString(),
            ConfirmedMusiciansList: confirmedMusiciansReport,
            ProjectID: currentProjectID
          });
          sendEmailWithOptionalAttachments(adminEmailVal, adminSubject, adminHtml);
      }
    
    } else if (!projectHasNeeds && projectRowArray[projStatusCol] === "Active") {
        logEvent("INFO", "checkProjectCompletion", currentProjectID, null, null, `Project ${currentProjectID} Active, no needs.`);
    } else if (projectHasNeeds && !allNeedsFilled && projectRowArray[projStatusCol] === "Completed" && projectIDToForceCheck === currentProjectID) {
        logEvent("WARNING", "checkProjectCompletion", currentProjectID, null, null, `Project ${currentProjectID} 'Completed' but forced check found unfilled needs.`);
    }
  }
  logEvent("INFO", "checkProjectCompletion", projectIDToForceCheck, null, null, "Finished project completion check.");
}

function createTriggersIfMissing() {
  const SCRIPT_ID = ScriptApp.getScriptId(); 
  const requiredFunctions = [
    { name: "sendInitialRequests", intervalMinutes: getConfig("TriggerInterval_InitialRequests") || 60}, 
    { name: "checkReminders", intervalMinutes: getConfig("TriggerInterval_Reminders") || 15 }, 
    { name: "checkDeadlines", intervalMinutes: getConfig("TriggerInterval_Deadlines") || 15 }, 
    { name: "checkProjectCompletion", intervalMinutes: getConfig("TriggerInterval_Completion") || 60 } 
  ];
  const existingTriggers = ScriptApp.getProjectTriggers();
  let newTriggersCreated = false;

  requiredFunctions.forEach(triggerInfo => {
    const triggerExists = existingTriggers.some(t => t.getHandlerFunction() === triggerInfo.name);
    if (!triggerExists) {
      try {
        const interval = parseInt(triggerInfo.intervalMinutes, 10);
        if (isNaN(interval) || interval < 5) { 
            logEvent("WARNING", "createTriggersIfMissing", null, null, null, `Invalid interval ${triggerInfo.intervalMinutes} for ${triggerInfo.name}. Defaulting to 60.`);
            triggerInfo.intervalMinutes = 60;
        }
        ScriptApp.newTrigger(triggerInfo.name)
          .timeBased()
          .everyMinutes(triggerInfo.intervalMinutes)
          .create();
        logEvent("INFO", "createTriggersIfMissing", null, null, null, `Created trigger: ${triggerInfo.name} (every ${triggerInfo.intervalMinutes} mins).`);
        newTriggersCreated = true;
      } catch (e) {
        logEvent("ERROR", "createTriggersIfMissing", null, null, null, `Failed to create trigger for ${triggerInfo.name}: ${e.message}`);
      }
    }
  });
}

function getProjectDetails(projectID) { 
    const sheet = getSheet("ProjectInfo");
    if (!sheet) return null;
    const data = sheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim());
    const projIdCol = headers.indexOf("ProjectID");
    if(projIdCol === -1) return null;

    const rowData = data.slice(1).find(r => r[projIdCol] === projectID);
    if (!rowData) return null;
    const details = {};
    headers.forEach((h, i) => details[h] = rowData[i]);
    return details;
}

function getNeedDetails(needID) { 
    const sheet = getSheet("Needs");
    if (!sheet) return null;
    const data = sheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim());
    const needIdCol = headers.indexOf("NeedID");
    if(needIdCol === -1) return null;

    const rowData = data.slice(1).find(r => r[needIdCol] === needID);
    if (!rowData) return null;
    const details = {};
    headers.forEach((h, i) => details[h] = rowData[i]);

    const iqID = details.InstrumentQualificationID;
    const iqLinkData = getMusicianDbSheetData("InstrumentQualification_Link");
    if (iqLinkData && iqLinkData.length > 1) {
        const iqLinkHeaders = iqLinkData[0].map(h => String(h).trim());
        const iqLinkIQIdCol = iqLinkHeaders.indexOf("InstrumentQualificationID");
        const iqLinkRoleIdCol = iqLinkHeaders.indexOf("SpecificRoleNameForInstrument");
        const iqLinkInstIdCol = iqLinkHeaders.indexOf("InstrumentID");

        const iqLinkRow = iqLinkData.slice(1).find(r => r[iqLinkIQIdCol] === iqID);
        if (iqLinkRow) {
            details.QualificationName = iqLinkRow[iqLinkRoleIdCol];
            const instrumentID = iqLinkRow[iqLinkInstIdCol];
            const instrumentsData = getMusicianDbSheetData("Instruments_Definition");
            if(instrumentsData && instrumentsData.length > 1){
                const instHeaders = instrumentsData[0].map(h => String(h).trim());
                const instIdCol = instHeaders.indexOf("InstrumentID");
                const instNameCol = instHeaders.indexOf("InstrumentName");
                const instRow = instrumentsData.slice(1).find(r => r[instIdCol] === instrumentID);
                if(instRow) details.InstrumentName = instRow[instNameCol];
            }
        }
    }
    details.InstrumentName = details.InstrumentName || details.InstrumentID || "N/A"; 
    details.QualificationName = details.QualificationName || details.InstrumentQualificationID || "N/A"; 
    return details;
}

function countCurrentYesForNeed(needID, responseTrackingFullData) {
    let count = 0;
    const headers = responseTrackingFullData[0].map(h => String(h).trim());
    const needIdCol = headers.indexOf("NeedID");
    const statusCol = headers.indexOf("ResponseStatus");
    if(needIdCol === -1 || statusCol === -1) return 0;

    for (let i = 1; i < responseTrackingFullData.length; i++) {
        if (responseTrackingFullData[i][needIdCol] === needID && responseTrackingFullData[i][statusCol] === "Yes") {
            count++;
        }
    }
    return count;
}
function getNeedRowIndex(needID){ 
    const needsSheet = getSheet("Needs");
    if(!needsSheet) return -1;
    const data = needsSheet.getRange("A:A").getValues(); 
    for(let i=1; i < data.length; i++){ 
        if(data[i][0] === needID) return i; 
    }
    return -1;
}
function getNeedsStatusColIndex(){ 
    const needsSheet = getSheet("Needs");
    if(!needsSheet) return -1;
    return needsSheet.getRange(1,1,1,needsSheet.getLastColumn()).getValues()[0].map(h => String(h).trim()).indexOf("NeedStatus");
}


function checkReminders_MENU() { 
  logEvent("INFO", "checkReminders_MENU", null,null,null, "Manual execution by admin.");
  checkReminders(); 
  SpreadsheetApp.getUi().alert("Påminnelser kontrollerade. Se EventLog.");
}
function checkDeadlines_MENU() { 
  logEvent("INFO", "checkDeadlines_MENU", null,null,null, "Manual execution by admin.");
  checkDeadlines(); 
  SpreadsheetApp.getUi().alert("Deadlines kontrollerade. Se EventLog.");
}
function checkProjectCompletion_MENU() { 
  logEvent("INFO", "checkProjectCompletion_MENU", null,null,null, "Manual execution by admin.");
  checkProjectCompletion(); 
  SpreadsheetApp.getUi().alert("Projektavslut kontrollerade. Se EventLog.");
}


// ==========================================================================
//  SLUT PÅ BLOCK 4
// ==========================================================================
// ==========================================================================
//  BLOCK 5: ADMIN UTILITY FUNCTIONS (Archive, Reset)
// ==========================================================================

function archiveProject(projectIDToArchive, allowUiInteraction = false) {
  Logger.log(`archiveProject - Attempting to archive ProjectID: '${projectIDToArchive}'. UI allowed: ${allowUiInteraction}`);
  
  let ui = null; 
  if (allowUiInteraction) {
    try { ui = SpreadsheetApp.getUi(); } catch (e) { allowUiInteraction = false; }
  }

  if (!projectIDToArchive || typeof projectIDToArchive !== 'string' || !projectIDToArchive.trim()) {
    const errorMessage = "Ogiltigt eller tomt ProjektID för arkivering.";
    if (allowUiInteraction && ui) { ui.alert("Error", errorMessage, ui.ButtonSet.OK); }
    throw new Error(errorMessage);
  }

  const validProjectID = projectIDToArchive.trim();
  let projectArchivedData = {
      projectID: validProjectID, status: "Archived", projectName: "Okänt projekt"
  };

  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);

    const piSheet = getSheet("ProjectInfo");
    const needsSheet = getSheet("Needs");
    const rtSheet = getSheet("ResponseTracking");

    const archivePiSheet = getSheet("Archive_ProjectInfo");
    const archiveNeedsSheet = getSheet("Archive_Needs");
    const archiveRtSheet = getSheet("Archive_ResponseTracking");
    
    if (!piSheet || !archivePiSheet || !needsSheet || !archiveNeedsSheet || !rtSheet || !archiveRtSheet) {
        throw new Error("En eller flera nödvändiga produktions- eller arkivflikar kunde inte hittas.");
    }
    
    let projectFound = false;
    const piData = piSheet.getDataRange().getValues();
    const piHeaders = piData[0].map(h => String(h).trim());
    const piIdCol = piHeaders.indexOf("ProjectID");
    const piStatusCol = piHeaders.indexOf("ProjectStatus");
    const piNameCol = piHeaders.indexOf("ProjectName"); 
    const piLastModCol = piHeaders.indexOf("LastModified");

    if (piIdCol === -1 || piStatusCol === -1 || piNameCol === -1 || piLastModCol === -1) {
         throw new Error("Nödvändiga kolumner saknas i ProjectInfo-fliken.");
    }
    
    let projectRowToArchive;
    let projectRowIndexInSheet = -1;

    for (let i = 1; i < piData.length; i++) {
        if (piData[i][piIdCol] === validProjectID) {
            projectFound = true;
            projectRowToArchive = piData[i];
            projectRowIndexInSheet = i + 1;
            projectArchivedData.projectName = projectRowToArchive[piNameCol] || projectArchivedData.projectName;
            break;
        }
    }
    
    if (!projectFound) {
      throw new Error(`Projekt med ID '${validProjectID}' hittades inte i ProjectInfo.`);
    }

    if (archivePiSheet.getLastRow() === 0 || JSON.stringify(archivePiSheet.getRange(1,1,1,piHeaders.length).getValues()[0].map(h=>String(h).trim())) !== JSON.stringify(piHeaders)) {
        archivePiSheet.clearContents(); 
        archivePiSheet.appendRow(piHeaders);
    }
    const archivedProjectRow = [...projectRowToArchive]; 
    archivedProjectRow[piStatusCol] = "Archived"; 
    archivedProjectRow[piLastModCol] = new Date();
    archivePiSheet.appendRow(archivedProjectRow); 
    Logger.log(`Project '${validProjectID}' row copied to Archive_ProjectInfo with status Archived.`);
    
    piSheet.getRange(projectRowIndexInSheet, piStatusCol + 1).setValue("Archived");
    piSheet.getRange(projectRowIndexInSheet, piLastModCol + 1).setValue(new Date());
    Logger.log(`Project '${validProjectID}' status updated in ProjectInfo.`);


    function moveMatchingRows(sourceSheet, archiveSheet, idColName, targetProjectID) {
        const sourceData = sourceSheet.getDataRange().getValues();
        if (sourceData.length < 2) return 0; 
        const sourceHeaders = sourceData[0].map(h => String(h).trim());
        const colIdx = sourceHeaders.indexOf(idColName);
        if (colIdx === -1) {
            Logger.log(`moveMatchingRows - Column ${idColName} not found in ${sourceSheet.getName()}. Skipping.`);
            return 0;
        }

        if (archiveSheet.getLastRow() === 0 || JSON.stringify(archiveSheet.getRange(1,1,1,sourceHeaders.length).getValues()[0].map(h=>String(h).trim())) !== JSON.stringify(sourceHeaders)) {
            archiveSheet.clearContents();
            archiveSheet.appendRow(sourceHeaders);
        }
        
        const rowsToKeep = [sourceHeaders];
        const rowsToArchive = [];
        let movedCount = 0;

        for (let i = 1; i < sourceData.length; i++) {
            if (sourceData[i][colIdx] === targetProjectID) {
                rowsToArchive.push(sourceData[i]);
                movedCount++;
            } else {
                rowsToKeep.push(sourceData[i]);
            }
        }

        if (movedCount > 0) {
            if (rowsToArchive.length > 0) archiveSheet.getRange(archiveSheet.getLastRow() + 1, 1, rowsToArchive.length, sourceHeaders.length).setValues(rowsToArchive);
            sourceSheet.clearContents();
            if (rowsToKeep.length > 0) sourceSheet.getRange(1, 1, rowsToKeep.length, sourceHeaders.length).setValues(rowsToKeep);
            else if(sourceHeaders.length > 0) sourceSheet.getRange(1,1,1,sourceHeaders.length).setValues([sourceHeaders]); // only headers remain
            Logger.log(`${movedCount} rows for project '${targetProjectID}' moved from ${sourceSheet.getName()} to ${archiveSheet.getName()}.`);
        }
        return movedCount;
    }

    moveMatchingRows(needsSheet, archiveNeedsSheet, "ProjectID", validProjectID);
    moveMatchingRows(rtSheet, archiveRtSheet, "ProjectID", validProjectID);
    
    const successDetails = `Projekt "${projectArchivedData.projectName}" (ID: ${validProjectID}) har arkiverats.`;
    logEvent("SUCCESS", "archiveProject", validProjectID, null, null, successDetails);
    
    if (allowUiInteraction && ui) { ui.alert("Success", successDetails, ui.ButtonSet.OK); }
    return projectArchivedData;

  } catch (e) {
    Logger.log(`archiveProject - Error for ProjectID '${validProjectID}': ${e.message} ${e.stack ? e.stack : ''}`);
    logEvent("ERROR", "archiveProject", validProjectID, null, null, `Error: ${e.message}`);
    if (allowUiInteraction && ui) { ui.alert("Error", `Could not archive project ${validProjectID}: ${e.message}`, ui.ButtonSet.OK); }
    throw e;
  } finally {
    if (lock) { lock.releaseLock(); }
  }
}

function archiveProject_MENU() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt(
    "Archive Project",
    "Enter the ProjectID of the project you want to archive:",
    ui.ButtonSet.OK_CANCEL
  );

  if (response.getSelectedButton() == ui.Button.OK) {
    const projectIDToArchive = response.getResponseText().trim();
    if (projectIDToArchive) {
      const confirmResponse = ui.alert(
        "Confirm Archive",
        `Are you sure you want to archive all data for ProjectID: ${projectIDToArchive}?\nThis will set the project status to 'Archived' and move related Needs and Responses to archive sheets. Original ProjectInfo entry will be updated to 'Archived', not deleted.`,
        ui.ButtonSet.YES_NO
      );
      if (confirmResponse == ui.Button.YES) {
        try {
          archiveProject(projectIDToArchive, true); 
        } catch (e) {
          // Error is handled by archiveProject if UI is allowed
        }
      }
    } else {
      ui.alert("Archive Project", "No ProjectID entered.", ui.ButtonSet.OK);
    }
  }
}


function resetProject_MENU() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt(
    "Reset Project Data",
    "Enter the ProjectID of the project you want to reset (this will DELETE its data from Needs, ResponseTracking, and EventLog):",
    ui.ButtonSet.OK_CANCEL
  );

  if (response.getSelectedButton() == ui.Button.OK) {
    const projectIDToReset = response.getResponseText().trim();
    if (projectIDToReset) {
      const confirmResponse = ui.alert(
        "Confirm Reset",
        `DANGER! Are you sure you want to reset ProjectID: ${projectIDToReset}?\nThis will PERMANENTLY DELETE related data from Needs, ResponseTracking, and EventLog.\nProjectInfo entry will NOT be deleted but its status can be changed.`,
        ui.ButtonSet.YES_NO
      );
      if (confirmResponse == ui.Button.YES) {
        resetProject(projectIDToReset); 
      }
    } else {
      ui.alert("Reset Project", "No ProjectID entered.", ui.ButtonSet.OK);
    }
  }
}

function resetProject(projectID) {
  const ui = SpreadsheetApp.getUi();
  logEvent("INFO", "resetProject", projectID, null, null, `Attempting to reset project.`);

  const sheetsToClearRowsFrom = [
    { name: "Needs", idColumn: "ProjectID" },
    { name: "ResponseTracking", idColumn: "ProjectID" },
    { name: "EventLog", idColumn: "ProjectID" }
  ];
  let successCount = 0;
  let errorCount = 0;

  sheetsToClearRowsFrom.forEach(sheetInfo => {
    const sheet = getSheet(sheetInfo.name);
    if (!sheet) {
      logEvent("ERROR", "resetProject", projectID, null, null, `Sheet "${sheetInfo.name}" not found.`);
      errorCount++;
      return;
    }

    const data = sheet.getDataRange().getValues();
    if (data.length < 2) { 
      return;
    }
    const headers = data[0].map(h => String(h).trim());
    const idColumnIndex = headers.indexOf(sheetInfo.idColumn);

    if (idColumnIndex === -1) {
      logEvent("ERROR", "resetProject", projectID, null, null, `Could not find "${sheetInfo.idColumn}" column in "${sheetInfo.name}".`);
      errorCount++;
      return;
    }

    const remainingRows = [headers];
    let rowsDeletedCount = 0;
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][idColumnIndex]) !== String(projectID)) {
        remainingRows.push(data[i]);
      } else {
        rowsDeletedCount++;
      }
    }

    if (rowsDeletedCount > 0) {
      sheet.clearContents();
      if (remainingRows.length > 0) {
          sheet.getRange(1, 1, remainingRows.length, headers.length).setValues(remainingRows);
      } else if (headers.length > 0) { 
           sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
      }
      logEvent("INFO", "resetProject", projectID, null, null, `Deleted ${rowsDeletedCount} rows from "${sheetInfo.name}".`);
      successCount++;
    }
  });

  const projectInfoSheet = getSheet("ProjectInfo");
  if (projectInfoSheet) {
    const piData = projectInfoSheet.getDataRange().getValues();
    const piHeaders = piData[0].map(h => String(h).trim());
    const piProjectIDCol = piHeaders.indexOf("ProjectID");
    const piStatusCol = piHeaders.indexOf("ProjectStatus");
    const piLastModCol = piHeaders.indexOf("LastModified");


    if (piProjectIDCol !== -1 && piStatusCol !== -1 && piLastModCol !== -1) {
      for (let i = 1; i < piData.length; i++) {
        if (piData[i][piProjectIDCol] === projectID) {
          projectInfoSheet.getRange(i + 1, piStatusCol + 1).setValue("Planned"); 
          projectInfoSheet.getRange(i + 1, piLastModCol + 1).setValue(new Date());
          logEvent("INFO", "resetProject", projectID, null, null, `Status for ProjectID ${projectID} in ProjectInfo set to "Planned".`);
          successCount++;
          break;
        }
      }
    } else {
        logEvent("ERROR", "resetProject", projectID, null, null, "Critical columns missing in ProjectInfo sheet. Could not update status.");
        errorCount++;
    }
  } else {
      logEvent("ERROR", "resetProject", projectID, null, null, "ProjectInfo sheet not found. Could not update project status.");
      errorCount++;
  }

  if (errorCount > 0) {
    ui.alert("Reset Project", `Reset process completed with ${errorCount} error(s). Please check EventLog.`, ui.ButtonSet.OK);
  } else if (successCount > 0) {
    ui.alert("Reset Project", `ProjectID ${projectID} has been reset. Related data deleted. ProjectInfo status set to 'Planned'.`, ui.ButtonSet.OK);
  } else {
    ui.alert("Reset Project", `No data was found or modified for ProjectID ${projectID}.`, ui.ButtonSet.OK);
  }
}

// ==========================================================================
//  SLUT PÅ BLOCK 5 - ADMIN UTILS
// ==========================================================================
// ==========================================================================
//  BLOCK 6: FRONTEND DATA PROVIDERS (getters)
// ==========================================================================
function getProjectsForList() {
  try {
    const piSheet = getSheet("ProjectInfo"); 
    if (!piSheet) {
      throw new Error("ProjectInfo sheet not found.");
    }
    const piData = piSheet.getDataRange().getValues();
    if (piData.length < 2) return []; 
    
    const piHeaders = piData[0].map(h => String(h).trim());
    const idCol = piHeaders.indexOf("ProjectID");
    const nameCol = piHeaders.indexOf("ProjectName");
    const weekCol = piHeaders.indexOf("WeekNumber");
    const statusCol = piHeaders.indexOf("ProjectStatus");

    if ([idCol,nameCol,weekCol,statusCol].includes(-1)) {
        throw new Error("One or more required columns (ProjectID, ProjectName, WeekNumber, ProjectStatus) not found in ProjectInfo sheet.");
    }
    const projectsOutput = [];
    for (let i = 1; i < piData.length; i++) { 
      const projectRow = piData[i];
      if (!projectRow[idCol]) continue; 
      projectsOutput.push({
        ProjectID: projectRow[idCol], ProjectName: projectRow[nameCol],
        WeekNumber: projectRow[weekCol], ProjectStatus: projectRow[statusCol]
      });
    }
    return projectsOutput;
  } catch (error) {
    logEvent("ERROR", "getProjectsForList", null, null, null, `Error: ${error.message}`);
    throw error; 
  }
}

function getProjectDetailsForFrontend(projectID) {
  if (!projectID) {
    throw new Error("Inget ProjektID angavs.");
  }
  try {
    const projectDetails = getProjectDetails(projectID); 
    if (!projectDetails) {
      throw new Error(`Projekt med ID ${projectID} hittades inte.`);
    }

    if (projectDetails.LastModified && projectDetails.LastModified instanceof Date) {
        projectDetails.LastModified = projectDetails.LastModified.toLocaleString();
    }
    if (projectDetails.CreatedDate && projectDetails.CreatedDate instanceof Date) {
        projectDetails.CreatedDate = projectDetails.CreatedDate.toLocaleString();
    }
    
    projectDetails.needs = []; 
    const needsSheet = getSheet("Needs");
    if (needsSheet) {
      const needsData = needsSheet.getDataRange().getValues();
      if (needsData.length > 1) {
        const nHeaders = needsData[0].map(h => String(h).trim());
        const nProjectIdCol = nHeaders.indexOf("ProjectID");
        const nNeedIdCol = nHeaders.indexOf("NeedID");
        if (nProjectIdCol !== -1 && nNeedIdCol !== -1) {
          for (let j = 1; j < needsData.length; j++) {
            const needRow = needsData[j];
            if (needRow[nProjectIdCol] === projectID) {
              const need = {};
              nHeaders.forEach((header, index) => {
                need[header] = needRow[index];
              });
              const needFullDetails = getNeedDetails(need.NeedID); 
              need.InstrumentName = needFullDetails ? (needFullDetails.InstrumentName || need.InstrumentID) : need.InstrumentID;
              need.QualificationName = needFullDetails ? (needFullDetails.QualificationName || need.InstrumentQualificationID) : need.InstrumentQualificationID;
              projectDetails.needs.push(need);
            }
          }
        }
      }
    }
    return projectDetails;
  } catch (error) {
    logEvent("ERROR", "getProjectDetailsForFrontend", projectID, null, null, `Error: ${error.message}`);
    throw error;
  }
}

function getInstrumentsForDropdown() {
  try {
    const instruments = getAllInstruments(); 
    if (!instruments) return [];
    return instruments.map(inst => ({ 
        id: inst.InstrumentID, 
        name: inst.InstrumentName 
    })).sort((a,b) => String(a.name).localeCompare(String(b.name)));
  } catch (e) {
    logEvent("ERROR", "getInstrumentsForDropdown", null, null, null, `Error: ${e.message}`);
    throw e;
  }
}

function getQualificationsForInstrumentForDropdown(instrumentID) {
  if (!instrumentID) return [];
  try {
    const qualifications = getInstrumentQualifications(instrumentID); 
    if (!qualifications) return [];
    return qualifications.map(q => ({
        id: q.InstrumentQualificationID,
        name: q.SpecificRoleNameForInstrument
    })).sort((a,b) => String(a.name).localeCompare(String(b.name)));
  } catch (e) {
    logEvent("ERROR", "getQualificationsForInstrumentForDropdown", null, null, null, `Error for InstID ${instrumentID}: ${e.message}`);
    throw e;
  }
}

function getRankingListsForQualificationForDropdown(instrumentQualificationID) {
  if (!instrumentQualificationID) return [];
  try {
    const rankingLists = getAllRankingListDefinitions(instrumentQualificationID); 
    if (!rankingLists) return [];
    return rankingLists
        .filter(rl => rl.Status === "Active") 
        .map(rl => ({
            id: rl.RankingListID,
            name: rl.RankingListName
        })).sort((a,b) => String(a.name).localeCompare(String(b.name)));
  } catch (e) {
    logEvent("ERROR", "getRankingListsForQualificationForDropdown", null, null, null, `Error for IQ_ID ${instrumentQualificationID}: ${e.message}`);
    throw e;
  }
}

function getNeedDetailsForEdit(needID) {
  if (!needID) throw new Error("Inget BehovsID angavs.");
  try {
    const needDetails = getNeedDetails(needID); 
    if (!needDetails) {
      throw new Error(`Behov med ID ${needID} hittades inte.`);
    }
    return needDetails;
  } catch (error) {
    logEvent("ERROR", "getNeedDetailsForEdit", null, needID, null, `Error: ${error.message}`);
    throw error;
  }
}

function getMusiciansListForFrontend() { 
  const SCRIPT_NAME = "getMusiciansListForFrontend"; 
  try {
    const musicianDBId = getConfig('MusicianDatabaseID'); 
    if (!musicianDBId) {
      throw new Error("Configuration error: Musician Database ID not found.");
    }
    let musicianSpreadsheet;
    try { musicianSpreadsheet = SpreadsheetApp.openById(musicianDBId); } 
    catch (e) { throw new Error(`Server error: Could not access musician database. ${e.message}`);}

    const instrumentsSheet = musicianSpreadsheet.getSheetByName('Instruments_Definition');
    if (!instrumentsSheet) throw new Error("Data error: Instruments_Definition sheet not found.");
    
    const instrumentsData = instrumentsSheet.getDataRange().getValues();
    const instrumentMap = new Map();
    if (instrumentsData.length > 1 && instrumentsData[0].length > 1) { 
        const instIdColIdx = String(instrumentsData[0][0]).trim() === "InstrumentID" ? 0 : instrumentsData[0].map(h=>String(h).trim()).indexOf("InstrumentID");
        const instNameColIdx = String(instrumentsData[0][1]).trim() === "InstrumentName" ? 1 : instrumentsData[0].map(h=>String(h).trim()).indexOf("InstrumentName");

        if (instIdColIdx !== -1 && instNameColIdx !== -1) {
            for (let i = 1; i < instrumentsData.length; i++) {
                const instrumentId = instrumentsData[i][instIdColIdx] ? String(instrumentsData[i][instIdColIdx]).trim() : null;
                const instrumentName = instrumentsData[i][instNameColIdx] ? String(instrumentsData[i][instNameColIdx]).trim() : null;
                if (instrumentId && instrumentName) instrumentMap.set(instrumentId, instrumentName);
            }
        } else {
            logEvent("WARNING", SCRIPT_NAME, null,null,null,"InstrumentID or InstrumentName column not found in Instruments_Definition as expected.");
        }
    }

    const musiciansSheet = musicianSpreadsheet.getSheetByName('Musicians_MasterList');
    if (!musiciansSheet) throw new Error("Data error: Musicians_MasterList sheet not found.");
    
    const musiciansSheetData = musiciansSheet.getDataRange().getValues();
    const musiciansArray = [];
    if (musiciansSheetData.length < 2) return []; 

    const headers = musiciansSheetData[0].map(header => String(header).trim());
    const musicianIdCol = headers.indexOf('MusicianID');
    const firstNameCol = headers.indexOf('FirstName');
    const lastNameCol = headers.indexOf('LastName');
    const emailCol = headers.indexOf('Email');
    const phoneCol = headers.indexOf('Phone');
    const primaryInstrumentIdCol = headers.indexOf('PrimaryInstrumentID');
    const statusCol = headers.indexOf('Status'); 

    if ([musicianIdCol, firstNameCol, lastNameCol].some(idx => idx === -1)) { 
        throw new Error(`Data integrity error: Critical columns missing in Musicians_MasterList.`);
    }

    for (let i = 1; i < musiciansSheetData.length; i++) {
      const row = musiciansSheetData[i];
      const musicianId = row[musicianIdCol] ? String(row[musicianIdCol]).trim() : null;
      if (!musicianId) continue; 

      const primaryInstrumentId = primaryInstrumentIdCol !== -1 && row[primaryInstrumentIdCol] ? String(row[primaryInstrumentIdCol]).trim() : null;
      const primaryInstrumentName = primaryInstrumentId ? (instrumentMap.get(primaryInstrumentId) || "Okänt (" + primaryInstrumentId + ")") : "Ej angett";

      musiciansArray.push({
        musicianId: musicianId,
        firstName: row[firstNameCol] ? String(row[firstNameCol]).trim() : '',
        lastName: row[lastNameCol] ? String(row[lastNameCol]).trim() : '',
        email: emailCol !== -1 && row[emailCol] ? String(row[emailCol]).trim() : '',
        phone: phoneCol !== -1 && row[phoneCol] ? String(row[phoneCol]).trim() : '',
        primaryInstrumentName: primaryInstrumentName,
        status: statusCol !== -1 && row[statusCol] ? String(row[statusCol]).trim() : 'Active' 
      });
    }
    return musiciansArray;
  } catch (e) {
    logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error - ${e.message}. Stack: ${e.stack}`);
    throw e; 
  }
}

function getMusicianDetailsForEdit(musicianId) { 
  const SCRIPT_NAME = "getMusicianDetailsForEdit";
  try {
    if (!musicianId) throw new Error("Musiker-ID saknas.");
    
    const musicianDBId = getConfig('MusicianDatabaseID');
    if (!musicianDBId) throw new Error("Konfigurationsfel: Musician Database ID hittades inte.");
    
    let db;
    try { db = SpreadsheetApp.openById(musicianDBId); } 
    catch (e) { throw new Error(`Serverfel: Kunde inte komma åt musikerdatabasen. ${e.message}`); }

    const masterListSheet = db.getSheetByName('Musicians_MasterList');
    if (!masterListSheet) throw new Error("Datafel: Fliken 'Musicians_MasterList' hittades inte.");
    
    const masterListData = masterListSheet.getDataRange().getValues();
    const masterHeaders = masterListData[0].map(h => String(h).trim());
    const mIdCol = masterHeaders.indexOf("MusicianID");
    const musicianDataRow = masterListData.slice(1).find(row => row[mIdCol] === musicianId);

    if (!musicianDataRow) throw new Error(`Musiker med ID ${musicianId} hittades inte.`);
    
    const musicianDetails = {};
    masterHeaders.forEach((header, index) => {
      musicianDetails[header] = musicianDataRow[index];
    });
    
    const instrumentsDefSheet = db.getSheetByName('Instruments_Definition');
    let instrumentsData = [];
    if (instrumentsDefSheet) {
        instrumentsData = instrumentsDefSheet.getDataRange().getValues();
        if (instrumentsData.length > 1 && instrumentsData[0].length > 1) {
            const instHeaders = instrumentsData[0].map(h => String(h).trim());
            const instIdCol = instHeaders.indexOf("InstrumentID");
            const instNameCol = instHeaders.indexOf("InstrumentName");
            if (musicianDetails.PrimaryInstrumentID && instIdCol !== -1 && instNameCol !== -1) {
                const instrumentRow = instrumentsData.slice(1).find(inst => inst[instIdCol] === musicianDetails.PrimaryInstrumentID);
                musicianDetails.primaryInstrumentName = instrumentRow ? instrumentRow[instNameCol] : "Okänt Huvudinstrument";
            } else {
                musicianDetails.primaryInstrumentName = "Ej angett";
            }
        } else { musicianDetails.primaryInstrumentName = "Ej angett (Instrument Def tom/felaktig)";}
    } else {
      musicianDetails.primaryInstrumentName = "Ej angett (Instruments_Definition saknas)";
    }

    musicianDetails.qualifications = [];
    const specificQualSheet = db.getSheetByName('MusicianSpecificQualifications_Link');
    const iqLinkSheet = db.getSheetByName('InstrumentQualification_Link'); 
    
    if (specificQualSheet && iqLinkSheet && instrumentsDefSheet && 
        specificQualSheet.getLastRow() > 1 && iqLinkSheet.getLastRow() > 1 && instrumentsDefSheet.getLastRow() > 1) {
      
        const specificQualData = specificQualSheet.getDataRange().getValues();
        const specificQualHeaders = specificQualData[0].map(h => String(h).trim());
        const msqIdCol = specificQualHeaders.indexOf("MusicianSpecificQualificationID");
        const msqMusicianIdCol = specificQualHeaders.indexOf("MusicianID");
        const msqIqIdCol = specificQualHeaders.indexOf("InstrumentQualificationID");

        const iqLinkData = iqLinkSheet.getDataRange().getValues();
        const iqLinkHeaders = iqLinkData[0].map(h => String(h).trim());
        const iqlIdCol = iqLinkHeaders.indexOf("InstrumentQualificationID"); 
        const iqlInstrumentIdCol = iqLinkHeaders.indexOf("InstrumentID"); 
        const iqlRoleNameCol = iqLinkHeaders.indexOf("SpecificRoleNameForInstrument"); 
        
        const instHeaders = instrumentsData[0].map(h => String(h).trim());
        const instIdCol = instHeaders.indexOf("InstrumentID");
        const instNameCol = instHeaders.indexOf("InstrumentName");

        if ([msqMusicianIdCol,msqIqIdCol,iqlIdCol,iqlInstrumentIdCol,iqlRoleNameCol,instIdCol,instNameCol].includes(-1) ) {
            logEvent("ERROR", SCRIPT_NAME, null, null, musicianId, "Critical column missing in qualification-related sheets.");
        } else {
            specificQualData.slice(1).forEach(sqRow => {
                if (sqRow[msqMusicianIdCol] === musicianId) {
                    const iqId = sqRow[msqIqIdCol];
                    const iqLinkRow = iqLinkData.slice(1).find(iqr => iqr[iqlIdCol] === iqId);
                    if (iqLinkRow) {
                        const instrumentIdFromLink = iqLinkRow[iqlInstrumentIdCol];
                        const instrumentDataRow = instrumentsData.slice(1).find(inst => inst[instIdCol] === instrumentIdFromLink);
                        musicianDetails.qualifications.push({
                            musicianSpecificQualificationId: sqRow[msqIdCol],
                            instrumentQualificationId: iqId,
                            instrumentId: instrumentIdFromLink,
                            instrumentName: instrumentDataRow ? instrumentDataRow[instNameCol] : "Okänt Instrument",
                            specificRoleName: iqLinkRow[iqlRoleNameCol] || "Okänd Roll"
                        });
                    }
                }
            });
        }
    }
    return musicianDetails;
  } catch (e) {
    logEvent("ERROR", SCRIPT_NAME, null, null, musicianId || "N/A", `Error: ${e.message}. Stack: ${e.stack}`);
    throw e; 
  }
}


// ==========================================================================
//  SLUT PÅ BLOCK 6 - FRONTEND GETTERS
// ==========================================================================
// ==========================================================================
//  BLOCK 7: FRONTEND DATA MODIFIERS (setters/actions)
// ==========================================================================

function createNewProject(projectData) {
  try {
    if (!projectData || !projectData.ProjectName || String(projectData.ProjectName).trim() === "") {
      throw new Error("Projektnamn måste anges.");
    }
    const piSheet = getSheet("ProjectInfo");
    if (!piSheet) throw new Error("Kunde inte hitta ProjectInfo-fliken.");
    
    const newProjectID = generateUniqueId("PROJ_");
    const headers = piSheet.getRange(1, 1, 1, piSheet.getLastColumn()).getValues()[0].map(h=>String(h).trim());
    const newRowData = {}; 

    newRowData["ProjectID"] = newProjectID;
    newRowData["ProjectName"] = String(projectData.ProjectName).trim();
    newRowData["WeekNumber"] = projectData.WeekNumber ? parseInt(projectData.WeekNumber, 10) : null;
    newRowData["RehearsalSchedule"] = projectData.RehearsalSchedule || null;
    newRowData["ConcertSchedule"] = projectData.ConcertSchedule || null;
    newRowData["ResponseDeadlineHours"] = (projectData.ResponseDeadlineHours !== null && projectData.ResponseDeadlineHours !== "") ? (parseInt(projectData.ResponseDeadlineHours, 10) || 0) : null;
    newRowData["DriveFolderID"] = projectData.DriveFolderID || null;
    newRowData["ProjectStatus"] = projectData.ProjectStatus || "Planned"; 
    newRowData["Notes"] = projectData.Notes || null;
    newRowData["LastModified"] = new Date();
    newRowData["CreatedDate"] = new Date();

    const newRowArray = headers.map(header => newRowData[header] !== undefined ? newRowData[header] : null);
    piSheet.appendRow(newRowArray);
    SpreadsheetApp.flush(); 
    logEvent("INFO", "createNewProject", newProjectID, null, null, `New project: ${projectData.ProjectName}`);
    return { ProjectID: newProjectID, ProjectName: projectData.ProjectName };
  } catch (e) {
    logEvent("ERROR", "createNewProject", null, null, null, `Error: ${e.message}`);
    throw e;
  }
}

function updateExistingProject(projectDataWithID) {
  try {
    if (!projectDataWithID || !projectDataWithID.ProjectID) {
      throw new Error("Projekt-ID saknas.");
    }
    if (!projectDataWithID.ProjectName || String(projectDataWithID.ProjectName).trim() === "") {
      throw new Error("Projektnamn får inte vara tomt.");
    }

    const piSheet = getSheet("ProjectInfo");
    if (!piSheet) throw new Error("Kunde inte hitta ProjectInfo-fliken.");
    
    const piData = piSheet.getDataRange().getValues();
    const headers = piData[0].map(h=>String(h).trim());
    const idCol = headers.indexOf("ProjectID");
    if (idCol === -1) throw new Error("ProjectID column not found.");

    let projectRowIndex = -1;
    for (let i = 1; i < piData.length; i++) {
      if (piData[i][idCol] === projectDataWithID.ProjectID) {
        projectRowIndex = i + 1; 
        break;
      }
    }
    if (projectRowIndex === -1) {
      throw new Error(`Projekt med ID ${projectDataWithID.ProjectID} hittades inte.`);
    }

    const updatedRowData = {};
    updatedRowData["ProjectID"] = projectDataWithID.ProjectID;
    updatedRowData["ProjectName"] = String(projectDataWithID.ProjectName).trim();
    updatedRowData["WeekNumber"] = projectDataWithID.WeekNumber ? parseInt(projectDataWithID.WeekNumber, 10) : null;
    updatedRowData["RehearsalSchedule"] = projectDataWithID.RehearsalSchedule || null;
    updatedRowData["ConcertSchedule"] = projectDataWithID.ConcertSchedule || null;
    updatedRowData["ResponseDeadlineHours"] = (projectDataWithID.ResponseDeadlineHours !== null && projectDataWithID.ResponseDeadlineHours !== "") ? (parseInt(projectDataWithID.ResponseDeadlineHours, 10) || 0) : null;
    updatedRowData["DriveFolderID"] = projectDataWithID.DriveFolderID || null;
    updatedRowData["ProjectStatus"] = projectDataWithID.ProjectStatus || "Planned";
    updatedRowData["Notes"] = projectDataWithID.Notes || null;
    updatedRowData["LastModified"] = new Date();
    const createdDateCol = headers.indexOf("CreatedDate");
    if (createdDateCol !== -1) updatedRowData["CreatedDate"] = piData[projectRowIndex-1][createdDateCol]; 

    const updatedRowArray = headers.map(header => updatedRowData[header] !== undefined ? updatedRowData[header] : piData[projectRowIndex-1][headers.indexOf(header)]); 

    piSheet.getRange(projectRowIndex, 1, 1, updatedRowArray.length).setValues([updatedRowArray]);
    SpreadsheetApp.flush();
    logEvent("INFO", "updateExistingProject", projectDataWithID.ProjectID, null, null, `Project updated: ${projectDataWithID.ProjectName}`);
    return { success: true, ProjectID: projectDataWithID.ProjectID, ProjectName: projectDataWithID.ProjectName };
  } catch (e) {
    logEvent("ERROR", "updateExistingProject", projectDataWithID ? projectDataWithID.ProjectID : 'Unknown', null, null, `Error: ${e.message}`);
    throw e;
  }
}

function createNewNeed(needDataFromFrontend) {
  try {
    if (!needDataFromFrontend || !needDataFromFrontend.ProjectID || !needDataFromFrontend.InstrumentID ||
        !needDataFromFrontend.InstrumentQualificationID || !needDataFromFrontend.RankingListID ||
        !needDataFromFrontend.NeededQuantity) {
      throw new Error("Nödvändiga fält saknas för att skapa behovet.");
    }
    const projectID = String(needDataFromFrontend.ProjectID).trim();
    const instrumentID = String(needDataFromFrontend.InstrumentID).trim();
    const instrumentQualificationID = String(needDataFromFrontend.InstrumentQualificationID).trim();
    const rankingListID = String(needDataFromFrontend.RankingListID).trim();
    const neededQuantity = parseInt(needDataFromFrontend.NeededQuantity, 10);

    if (isNaN(neededQuantity) || neededQuantity < 1) {
        throw new Error("Ogiltigt antal specificerat (minst 1).");
    }

    const needsSheet = getSheet("Needs");
    if (!needsSheet) throw new Error("'Needs' sheet not found.");
    
    const needsValues = needsSheet.getDataRange().getValues();
    const needsHeaders = needsValues[0].map(h => String(h).trim());
    const projectIDCol_N = needsHeaders.indexOf("ProjectID");
    const instrumentIDCol_N = needsHeaders.indexOf("InstrumentID");
    const qualIDCol_N = needsHeaders.indexOf("InstrumentQualificationID");
    const rankIDCol_N = needsHeaders.indexOf("RankingListID");

    for (let i = 1; i < needsValues.length; i++) {
      const row = needsValues[i];
      if (row[projectIDCol_N] && row[instrumentIDCol_N] && row[qualIDCol_N] && row[rankIDCol_N]) {
        if (String(row[projectIDCol_N]).trim() === projectID &&
            String(row[instrumentIDCol_N]).trim() === instrumentID &&
            String(row[qualIDCol_N]).trim() === instrumentQualificationID &&
            String(row[rankIDCol_N]).trim() === rankingListID) {
          throw new Error("Ett identiskt behov finns redan för detta projekt.");
        }
      }
    }

    const newNeedID = generateUniqueId("NEED_");
    const currentDate = new Date();
    const newRowValues = {};
    newRowValues["NeedID"] = newNeedID;
    newRowValues["ProjectID"] = projectID;
    newRowValues["InstrumentID"] = instrumentID;
    newRowValues["InstrumentQualificationID"] = instrumentQualificationID;
    newRowValues["RankingListID"] = rankingListID;
    newRowValues["NeededQuantity"] = neededQuantity;
    newRowValues["DispatchType"] = needDataFromFrontend.DispatchType || "Sequential";
    newRowValues["MaxParallelDispatches"] = (newRowValues.DispatchType === "FCFS" && needDataFromFrontend.MaxParallelDispatches) ? parseInt(needDataFromFrontend.MaxParallelDispatches, 10) : null;
    newRowValues["RequiresOwnAccomodation"] = needDataFromFrontend.RequiresOwnAccomodation === "YES" ? "YES" : "NO";
    newRowValues["NeedStatus"] = needDataFromFrontend.NeedStatus || "Active";
    newRowValues["Notes"] = needDataFromFrontend.Notes || "";
    newRowValues["AdminNotified_FilledTimestamp"] = null; 
    newRowValues["LastModified"] = currentDate; 
    newRowValues["CreatedDate"] = currentDate; 

    const newRowArray = needsHeaders.map(header => newRowValues[header] !== undefined ? newRowValues[header] : null);

    needsSheet.appendRow(newRowArray);
    logEvent("SUCCESS", "createNewNeed", projectID, newNeedID, null, "New need created.");
    
    const createdNeed = {};
    needsHeaders.forEach(header => {
        createdNeed[header] = newRowValues[header];
    });
    const fullDetails = getNeedDetails(newNeedID); 
    createdNeed.InstrumentName = fullDetails.InstrumentName;
    createdNeed.QualificationName = fullDetails.QualificationName;

    return createdNeed;
  } catch (e) {
    logEvent("ERROR", "createNewNeed", (needDataFromFrontend ? needDataFromFrontend.ProjectID : null), null, null, `Error: ${e.message}`);
    throw e;
  }
}

function updateExistingNeed(needDataObjectWithID) {
  try {
    if (!needDataObjectWithID || !needDataObjectWithID.NeedID) {
      throw new Error("Behovs-ID saknas.");
    }
    const needsSheet = getSheet("Needs");
    if (!needsSheet) throw new Error("Kunde inte hitta Needs-fliken.");
    
    const needsData = needsSheet.getDataRange().getValues();
    const headers = needsData[0].map(h => String(h).trim());
    const idCol = headers.indexOf("NeedID");
    if (idCol === -1) throw new Error("NeedID column not found.");

    let needRowIndex = -1;
    for (let i = 1; i < needsData.length; i++) {
      if (needsData[i][idCol] === needDataObjectWithID.NeedID) {
        needRowIndex = i + 1; 
        break;
      }
    }
    if (needRowIndex === -1) {
      throw new Error(`Behov med ID ${needDataObjectWithID.NeedID} hittades inte.`);
    }

    const updatedRowValues = {};
    updatedRowValues["NeedID"] = needDataObjectWithID.NeedID; 
    updatedRowValues["ProjectID"] = needDataObjectWithID.ProjectID; 
    updatedRowValues["InstrumentID"] = needDataObjectWithID.InstrumentID;
    updatedRowValues["InstrumentQualificationID"] = needDataObjectWithID.InstrumentQualificationID;
    updatedRowValues["RankingListID"] = needDataObjectWithID.RankingListID;
    updatedRowValues["NeededQuantity"] = parseInt(needDataObjectWithID.NeededQuantity, 10) || 1;
    updatedRowValues["DispatchType"] = needDataObjectWithID.DispatchType;
    updatedRowValues["MaxParallelDispatches"] = needDataObjectWithID.DispatchType === "FCFS" ? (parseInt(needDataObjectWithID.MaxParallelDispatches, 10) || 1) : null;
    updatedRowValues["RequiresOwnAccomodation"] = needDataObjectWithID.RequiresOwnAccomodation === "YES" ? "YES" : "NO";
    updatedRowValues["NeedStatus"] = needDataObjectWithID.NeedStatus || "Active";
    updatedRowValues["Notes"] = needDataObjectWithID.Notes || null;
    updatedRowValues["LastModified"] = new Date();
    
    const createdDateCol = headers.indexOf("CreatedDate");
    if (createdDateCol !== -1) updatedRowValues["CreatedDate"] = needsData[needRowIndex-1][createdDateCol];
    const adminNotifiedCol = headers.indexOf("AdminNotified_FilledTimestamp");
    if (adminNotifiedCol !== -1) updatedRowValues["AdminNotified_FilledTimestamp"] = needsData[needRowIndex-1][adminNotifiedCol];


    const updatedRowArray = headers.map(header => updatedRowValues[header] !== undefined ? updatedRowValues[header] : needsData[needRowIndex-1][headers.indexOf(header)]);

    needsSheet.getRange(needRowIndex, 1, 1, updatedRowArray.length).setValues([updatedRowArray]);
    SpreadsheetApp.flush();
    logEvent("INFO", "updateExistingNeed", needDataObjectWithID.ProjectID, needDataObjectWithID.NeedID, null, "Need updated.");
    return { success: true, NeedID: needDataObjectWithID.NeedID, ProjectID: needDataObjectWithID.ProjectID };
  } catch (e) {
    logEvent("ERROR", "updateExistingNeed", needDataObjectWithID ? needDataObjectWithID.ProjectID : 'Unknown', needDataObjectWithID ? needDataObjectWithID.NeedID : 'Unknown', null, `Error: ${e.message}`);
    throw e;
  }
}

function deleteNeedFromSheet(needIdToDelete) {
  if (!needIdToDelete || typeof needIdToDelete !== 'string' || !needIdToDelete.trim()) {
      throw new Error("Ogiltigt eller tomt behovs-ID för radering.");
  }
  const validNeedId = String(needIdToDelete).trim(); 
  const needsSheet = getSheet("Needs");
  const responseTrackingSheet = getSheet("ResponseTracking");

  if (!needsSheet) throw new Error("'Needs' sheet not found.");
  
  const needsData = needsSheet.getDataRange().getValues();
  const needsHeaders = needsData[0].map(h => String(h).trim());
  const needIDCol = needsHeaders.indexOf("NeedID");
  const projectIDCol = needsHeaders.indexOf("ProjectID"); 

  if (needIDCol === -1 || projectIDCol === -1) {
    throw new Error("Nödvändiga kolumner (NeedID, ProjectID) saknas i 'Needs'.");
  }

  let projectIDForDeletedNeed = null;
  let foundAndDeleted = false;

  const rowsToKeepNeeds = [needsHeaders];
  for (let i = 1; i < needsData.length; i++) { 
    if (needsData[i][needIDCol] === validNeedId) {
      projectIDForDeletedNeed = needsData[i][projectIDCol];
      foundAndDeleted = true;
    } else {
      rowsToKeepNeeds.push(needsData[i]);
    }
  }

  if (foundAndDeleted) {
    needsSheet.clearContents();
    if (rowsToKeepNeeds.length > 0) {
        needsSheet.getRange(1, 1, rowsToKeepNeeds.length, needsHeaders.length).setValues(rowsToKeepNeeds);
    } else if (needsHeaders.length > 0){
        needsSheet.getRange(1,1,1,needsHeaders.length).setValues([needsHeaders]);
    }

    if (responseTrackingSheet) {
      const rtData = responseTrackingSheet.getDataRange().getValues();
      if(rtData.length > 1){
        const rtHeaders = rtData[0].map(h => String(h).trim());
        const rtNeedIDCol = rtHeaders.indexOf("NeedID");
        if (rtNeedIDCol !== -1) {
          const rowsToKeepRT = [rtHeaders];
          for (let j = 1; j < rtData.length; j++) {
            if (rtData[j][rtNeedIDCol] !== validNeedId) {
              rowsToKeepRT.push(rtData[j]);
            }
          }
          responseTrackingSheet.clearContents();
          if(rowsToKeepRT.length > 0){
              responseTrackingSheet.getRange(1,1,rowsToKeepRT.length, rtHeaders.length).setValues(rowsToKeepRT);
          } else if (rtHeaders.length > 0) {
              responseTrackingSheet.getRange(1,1,1,rtHeaders.length).setValues([rtHeaders]);
          }
        }
      }
    }
    logEvent("SUCCESS", "deleteNeedFromSheet", projectIDForDeletedNeed, validNeedId, null, "Need deleted.");
    return { deletedNeedID: validNeedId, projectID: projectIDForDeletedNeed, message: `Behov ${validNeedId} raderat.` };
  } else {
    throw new Error(`Behov med ID '${validNeedId}' hittades inte.`);
  }
}

function createNewMusician(musicianDataObject) {
  const SCRIPT_NAME = "createNewMusician";
  let newMusicianId = null; 
  try {
    if (!musicianDataObject || typeof musicianDataObject !== 'object') {
      throw new Error("Ogiltig indata: Musikerdata saknas.");
    }
    const { firstName, lastName, email, phone, primaryInstrumentId, hasOwnAccomodation, status, qualifications, notes } = musicianDataObject; 

    if (!firstName || !lastName || !email) {
      throw new Error("Obligatoriska fält saknas: Förnamn, Efternamn och E-post.");
    }

    const musicianDB = getMusicianDatabaseSpreadsheet();
    if (!musicianDB) throw new Error("Kunde inte öppna musikerdatabasen.");

    const masterListSheet = musicianDB.getSheetByName('Musicians_MasterList');
    const specificQualSheet = musicianDB.getSheetByName('MusicianSpecificQualifications_Link');
    const rankingListsDefSheet = musicianDB.getSheetByName('RankingLists_Definition'); 
    const rankingsDataSheet = musicianDB.getSheetByName('Rankings_Data');             

    if (!masterListSheet || !specificQualSheet || !rankingListsDefSheet || !rankingsDataSheet) {
      throw new Error(`Ett eller flera datablad saknas i musikerdatabasen.`);
    }

    newMusicianId = generateUniqueId("MUS_");
    const currentDate = new Date();
    
    const masterHeaders = masterListSheet.getRange(1,1,1,masterListSheet.getLastColumn()).getValues()[0].map(h=>String(h).trim());
    const masterRowObject = {
        MusicianID: newMusicianId, FirstName: firstName, LastName: lastName, Email: email, 
        Phone: phone || "", PrimaryInstrumentID: primaryInstrumentId || "", 
        SecondaryInstrumentIDs: "", 
        HasOwnAccomodation: hasOwnAccomodation || "NO", 
        Notes: notes || "", 
        Status: status || "Active", 
        LastModified: currentDate, CreatedDate: currentDate
    };
    const newMasterRowArray = masterHeaders.map(header => masterRowObject[header] !== undefined ? masterRowObject[header] : null);
    masterListSheet.appendRow(newMasterRowArray);

    const processedQualIds = new Set(); 
    if (qualifications && Array.isArray(qualifications) && qualifications.length > 0) {
      const msqHeaders = specificQualSheet.getRange(1,1,1,specificQualSheet.getLastColumn()).getValues()[0].map(h=>String(h).trim());
      qualifications.forEach(qual => {
        if (qual && qual.instrumentQualificationId && !processedQualIds.has(qual.instrumentQualificationId)) {
          const newMsqId = generateUniqueId("MSQ_");
          const msqRowObject = { MusicianSpecificQualificationID: newMsqId, MusicianID: newMusicianId, InstrumentQualificationID: qual.instrumentQualificationId};
          const newMsqRowArray = msqHeaders.map(header => msqRowObject[header] !== undefined ? msqRowObject[header] : null);
          specificQualSheet.appendRow(newMsqRowArray);
          processedQualIds.add(qual.instrumentQualificationId);
        }
      });
    }

    if (processedQualIds.size > 0) {
      const rankingListsDefData = rankingListsDefSheet.getDataRange().getValues();
      const rankingsDataValues = rankingsDataSheet.getDataRange().getValues(); 
      const rldHeaders = rankingListsDefData[0].map(h=>String(h).trim());
      const rdHeaders = rankingsDataValues.length > 0 ? rankingsDataValues[0].map(h=>String(h).trim()) : [];

      const rldListIdCol = rldHeaders.indexOf("RankingListID"); 
      const rldAppliesToIqIdCol = rldHeaders.indexOf("AppliesTo_InstrumentQualificationID"); 
      const rldStatusCol = rldHeaders.indexOf("Status");
      const rdListIdCol = rdHeaders.indexOf("RankingListID");        
      const rdMusicianIdCol = rdHeaders.indexOf("MusicianID");      
      const rdRankOrderCol = rdHeaders.indexOf("RankOrder");        

      if ([rldListIdCol,rldAppliesToIqIdCol,rldStatusCol,rdListIdCol,rdMusicianIdCol,rdRankOrderCol].includes(-1)) {
          logEvent("WARNING", SCRIPT_NAME, null, null, newMusicianId, "Kolumner saknas i rankningslistor, kan ej uppdatera.");
      } else {
        processedQualIds.forEach(iqId => {
          for (let i = 1; i < rankingListsDefData.length; i++) { 
            const listDefRow = rankingListsDefData[i];
            if (listDefRow[rldAppliesToIqIdCol] === iqId && listDefRow[rldStatusCol] === "Active") { 
              const rankingListIdToAdd = listDefRow[rldListIdCol];
              let musicianAlreadyOnThisList = false;
              for (let j = 1; j < rankingsDataValues.length; j++) {
                if (rankingsDataValues[j][rdListIdCol] === rankingListIdToAdd && rankingsDataValues[j][rdMusicianIdCol] === newMusicianId) {
                  musicianAlreadyOnThisList = true; break;
                }
              }
              if (!musicianAlreadyOnThisList) {
                let maxRankOrder = 0;
                for (let j = 1; j < rankingsDataValues.length; j++) {
                  if (rankingsDataValues[j][rdListIdCol] === rankingListIdToAdd) {
                    const currentRank = parseInt(rankingsDataValues[j][rdRankOrderCol], 10);
                    if (!isNaN(currentRank) && currentRank > maxRankOrder) maxRankOrder = currentRank;
                  }
                }
                const newRankOrder = maxRankOrder + 1;
                const newRankingDataID = generateUniqueId("RD_");
                const rankDataRowObject = { RankingDataID: newRankingDataID, RankingListID: rankingListIdToAdd, MusicianID: newMusicianId, RankOrder: newRankOrder, Notes: ""};
                
                // Make sure rdHeaders are valid before mapping
                if (rdHeaders.length > 0) {
                    const newRankDataArray = rdHeaders.map(header => rankDataRowObject[header] !== undefined ? rankDataRowObject[header] : null);
                    rankingsDataSheet.appendRow(newRankDataArray);
                } else if (Object.keys(rankDataRowObject).length > 0) { // If sheet was empty, create headers first
                    const inferredHeaders = Object.keys(rankDataRowObject);
                    rankingsDataSheet.appendRow(inferredHeaders);
                    const newRankDataArray = inferredHeaders.map(header => rankDataRowObject[header]);
                    rankingsDataSheet.appendRow(newRankDataArray);
                }
              }
            }
          }
        });
      }
    }
    return { success: true, musicianId: newMusicianId, firstName: firstName, lastName: lastName, email: email };
  } catch (e) {
    logEvent("ERROR", SCRIPT_NAME, null, null, newMusicianId || "N/A", `Error: ${e.message}. Stack: ${e.stack}`);
    throw e;
  }
}

function updateExistingMusician(musicianData) {
  const SCRIPT_NAME = "updateExistingMusician";
  try {
    if (!musicianData || !musicianData.musicianId) {
      throw new Error("Musikerdata eller Musiker-ID saknas.");
    }
    const { musicianId, firstName, lastName, email, phone, primaryInstrumentId, hasOwnAccomodation, notes, status, qualifications } = musicianData;

    if (!firstName || !lastName || !email) {
      throw new Error("Obligatoriska fält saknas: Förnamn, Efternamn och E-post.");
    }
    
    const musicianDB = getMusicianDatabaseSpreadsheet();
    if (!musicianDB) throw new Error("Kunde inte öppna musikerdatabasen.");

    const masterListSheet = musicianDB.getSheetByName('Musicians_MasterList');
    if (!masterListSheet) throw new Error("Fliken 'Musicians_MasterList' hittades inte.");
    
    const data = masterListSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim());
    const idCol = headers.indexOf("MusicianID");
    if (idCol === -1) throw new Error("MusicianID column not found in MasterList.");

    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][idCol] === musicianId) {
        rowIndex = i; break;
      }
    }
    if (rowIndex === -1) throw new Error(`Musiker med ID ${musicianId} hittades inte.`);

    const rowToUpdate = rowIndex + 1;
    const updateValues = { 
        "FirstName": firstName, "LastName": lastName, "Email": email, 
        "Phone": phone || "", "PrimaryInstrumentID": primaryInstrumentId || "",
        "HasOwnAccomodation": hasOwnAccomodation || "NO", 
        "Notes": notes || "", "Status": status || "Active",
        "LastModified": new Date()
    };
    headers.forEach((header, colIdx) => {
        if (updateValues.hasOwnProperty(header)) {
            masterListSheet.getRange(rowToUpdate, colIdx + 1).setValue(updateValues[header]);
        }
    });

    const specificQualSheet = musicianDB.getSheetByName('MusicianSpecificQualifications_Link');
    if (specificQualSheet) {
        const sqData = specificQualSheet.getDataRange().getValues();
        const sqHeaders = sqData.length > 0 ? sqData[0].map(h=>String(h).trim()) : [];
        const sqMusicianIdCol = sqHeaders.indexOf("MusicianID");
        
        if(sqMusicianIdCol !== -1) {
            const rowsToKeepSQ = sqHeaders.length > 0 ? [sqHeaders] : [];
            for(let i=1; i < sqData.length; i++){
                if(sqData[i][sqMusicianIdCol] !== musicianId){
                    rowsToKeepSQ.push(sqData[i]);
                }
            }
            specificQualSheet.clearContents();
            if(rowsToKeepSQ.length > 0) specificQualSheet.getRange(1,1,rowsToKeepSQ.length, sqHeaders.length).setValues(rowsToKeepSQ);
            else if (sqHeaders.length > 0) specificQualSheet.getRange(1,1,1,sqHeaders.length).setValues([sqHeaders]);

            const submittedQualIds = new Set(qualifications ? qualifications.map(q => q.instrumentQualificationId) : []);
            submittedQualIds.forEach(iqId => {
                const newMsqId = generateUniqueId("MSQ_");
                const msqRowObject = { MusicianSpecificQualificationID: newMsqId, MusicianID: musicianId, InstrumentQualificationID: iqId};
                if (sqHeaders.length > 0) {
                    const newMsqRowArray = sqHeaders.map(header => msqRowObject[header] !== undefined ? msqRowObject[header] : null);
                    specificQualSheet.appendRow(newMsqRowArray);
                }
            });
            logEvent("INFO", SCRIPT_NAME, null, null, musicianId, "Qualifications updated. Ranking list impact not fully handled here.");
        }
    }

    return { success: true, musicianId: musicianId };
  } catch (e) {
    logEvent("ERROR", SCRIPT_NAME, null, null, musicianData ? musicianData.musicianId : "N/A", `Error: ${e.message}. Stack: ${e.stack}`);
    throw e;
  }
}


// ==========================================================================
//  SLUT PÅ BLOCK 7 - FRONTEND SETTERS
// ==========================================================================

// ==========================================================================
//  BLOCK 8: CRUD FOR DEFINITIONS (Instruments, Qualifications, RankingLists)
// ==========================================================================

// --- Instruments ---
function getInstrumentsAdminList() {
    try {
        const instruments = getAllInstruments(); 
        if (!instruments) return { error: "Could not retrieve instruments or sheet is empty."};
        return instruments; 
    } catch (e) {
        logEvent("ERROR", "getInstrumentsAdminList", null, null, null, `Error: ${e.message}`);
        throw e;
    }
}

function getInstrumentDetails(instrumentId) {
    if (!instrumentId) throw new Error("Instrument ID required.");
    try {
        const instruments = getAllInstruments();
        if (!instruments) throw new Error("Could not retrieve instruments.");
        const instrument = instruments.find(inst => inst.InstrumentID === instrumentId);
        if (!instrument) throw new Error(`Instrument with ID ${instrumentId} not found.`);
        return instrument;
    } catch (e) {
        logEvent("ERROR", "getInstrumentDetails", null, null, null, `Error for ID ${instrumentId}: ${e.message}`);
        throw e;
    }
}

function addInstrument(instrumentName) {
    if (!instrumentName || String(instrumentName).trim() === "") throw new Error("Instrument name is required.");
    const SCRIPT_NAME = "addInstrument";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("Instruments_Definition");
        if (!sheet) throw new Error("Instruments_Definition sheet not found.");

        // Check for duplicate name (optional, but good practice)
        const existingInstruments = getAllInstruments();
        if (existingInstruments && existingInstruments.some(inst => inst.InstrumentName.toLowerCase() === String(instrumentName).trim().toLowerCase())) {
            throw new Error(`An instrument with the name "${instrumentName}" already exists.`);
        }

        const newId = generateUniqueId("INST_");
        // Assuming headers: InstrumentID, InstrumentName, Notes
        sheet.appendRow([newId, String(instrumentName).trim(), ""]); 
        logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Added instrument: ${instrumentName} (ID: ${newId})`);
        return { InstrumentID: newId, InstrumentName: String(instrumentName).trim(), Notes: "" };
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error adding ${instrumentName}: ${e.message}`);
        throw e;
    }
}

function updateInstrument(payload) {
    if (!payload || !payload.InstrumentID) throw new Error("InstrumentID is required for update.");
    const SCRIPT_NAME = "updateInstrument";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("Instruments_Definition");
        if (!sheet) throw new Error("Instruments_Definition sheet not found.");

        const data = sheet.getDataRange().getValues();
        const headers = data[0].map(h => String(h).trim());
        const idCol = headers.indexOf("InstrumentID");
        const nameCol = headers.indexOf("InstrumentName");
        const notesCol = headers.indexOf("Notes");

        if (idCol === -1 || nameCol === -1 || notesCol === -1) throw new Error("Required columns missing in Instruments_Definition.");

        let rowIndex = -1;
        for (let i = 1; i < data.length; i++) {
            if (data[i][idCol] === payload.InstrumentID) {
                rowIndex = i + 1; break;
            }
        }
        if (rowIndex === -1) throw new Error(`Instrument ID ${payload.InstrumentID} not found.`);
        
        if (payload.InstrumentName !== undefined) {
             // Check for duplicate name if it's being changed
            if (payload.InstrumentName.toLowerCase() !== data[rowIndex-1][nameCol].toLowerCase()) {
                const existingInstruments = getAllInstruments();
                if (existingInstruments.some(inst => inst.InstrumentID !== payload.InstrumentID && inst.InstrumentName.toLowerCase() === payload.InstrumentName.toLowerCase())) {
                    throw new Error(`An instrument with the name "${payload.InstrumentName}" already exists.`);
                }
            }
            sheet.getRange(rowIndex, nameCol + 1).setValue(payload.InstrumentName);
        }
        if (payload.Notes !== undefined) {
            sheet.getRange(rowIndex, notesCol + 1).setValue(payload.Notes);
        }
        logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Updated instrument: ${payload.InstrumentID}`);
        return { success: true, instrument: payload }; // Return the updated payload
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error updating ${payload.InstrumentID}: ${e.message}`);
        throw e;
    }
}

function deleteInstrument(instrumentID) {
    if (!instrumentID) throw new Error("Instrument ID is required for deletion.");
    const SCRIPT_NAME = "deleteInstrument";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("Instruments_Definition");
        if (!sheet) throw new Error("Instruments_Definition sheet not found.");

        // Basic dependency check (example)
        const iqLinkSheet = musicianDB.getSheetByName("InstrumentQualification_Link");
        if (iqLinkSheet) {
            const iqData = iqLinkSheet.getDataRange().getValues();
            const iqHeaders = iqData.length > 0 ? iqData[0].map(h => String(h).trim()) : [];
            const iqInstIdCol = iqHeaders.indexOf("InstrumentID");
            if (iqInstIdCol !== -1) {
                for (let i=1; i < iqData.length; i++) {
                    if (iqData[i][iqInstIdCol] === instrumentID) {
                        throw new Error(`Cannot delete instrument ${instrumentID}. It is currently used in InstrumentQualification_Link.`);
                    }
                }
            }
        }


        const data = sheet.getDataRange().getValues();
        const headers = data[0].map(h => String(h).trim());
        const idCol = headers.indexOf("InstrumentID");
        if (idCol === -1) throw new Error("InstrumentID column not found.");
        
        const rowsToKeep = [headers];
        let deleted = false;
        for(let i=1; i < data.length; i++){
            if(data[i][idCol] === instrumentID){
                deleted = true;
            } else {
                rowsToKeep.push(data[i]);
            }
        }

        if (deleted) {
            sheet.clearContents();
            if (rowsToKeep.length > 0) sheet.getRange(1,1,rowsToKeep.length, headers.length).setValues(rowsToKeep);
            else if (headers.length > 0) sheet.getRange(1,1,1,headers.length).setValues([headers]);
            logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Deleted instrument: ${instrumentID}.`);
            return { success: true, deletedInstrumentID: instrumentID };
        } else {
            throw new Error(`Instrument ID ${instrumentID} not found for deletion.`);
        }
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error deleting ${instrumentID}: ${e.message}`);
        throw e;
    }
}

// --- Qualification Types ---
function getQualificationsAdminList() {
    try {
        const qTypes = getAllQualificationTypes(); // Uses Block 2 helper
        if (!qTypes) return { error: "Could not retrieve qualification types or sheet is empty."};
        return qTypes;
    } catch (e) {
        logEvent("ERROR", "getQualificationsAdminList", null, null, null, `Error: ${e.message}`);
        throw e;
    }
}

function getQualificationDetails(qualificationTypeId) {
    if (!qualificationTypeId) throw new Error("QualificationType ID required.");
    try {
        const qTypes = getAllQualificationTypes();
        if (!qTypes) throw new Error("Could not retrieve qualification types.");
        const qType = qTypes.find(qt => qt.QualificationTypeID === qualificationTypeId);
        if (!qType) throw new Error(`QualificationType with ID ${qualificationTypeId} not found.`);
        return qType;
    } catch (e) {
        logEvent("ERROR", "getQualificationDetails", null, null, null, `Error for ID ${qualificationTypeId}: ${e.message}`);
        throw e;
    }
}

function addQualificationType(payload) {
    const { QualificationName, Description } = payload;
    if (!QualificationName || String(QualificationName).trim() === "") throw new Error("Qualification Name is required.");
    const SCRIPT_NAME = "addQualificationType";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("QualificationTypes_Definition");
        if (!sheet) throw new Error("QualificationTypes_Definition sheet not found.");
        
        const existingQuals = getAllQualificationTypes();
        if (existingQuals && existingQuals.some(q => q.QualificationName.toLowerCase() === String(QualificationName).trim().toLowerCase())) {
            throw new Error(`A qualification type with the name "${QualificationName}" already exists.`);
        }

        const newId = generateUniqueId("QT_");
        // Headers: QualificationTypeID, QualificationName, Description
        sheet.appendRow([newId, String(QualificationName).trim(), Description || ""]); 
        logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Added QualificationType: ${QualificationName} (ID: ${newId})`);
        return { QualificationTypeID: newId, QualificationName: String(QualificationName).trim(), Description: Description || "" };
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error adding ${QualificationName}: ${e.message}`);
        throw e;
    }
}

function updateQualificationType(payload) {
    if (!payload || !payload.QualificationTypeID) throw new Error("QualificationTypeID is required for update.");
    const SCRIPT_NAME = "updateQualificationType";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("QualificationTypes_Definition");
        if (!sheet) throw new Error("QualificationTypes_Definition sheet not found.");

        const data = sheet.getDataRange().getValues();
        const headers = data[0].map(h => String(h).trim());
        const idCol = headers.indexOf("QualificationTypeID");
        const nameCol = headers.indexOf("QualificationName");
        const descCol = headers.indexOf("Description");
        if (idCol === -1 || nameCol === -1 || descCol === -1) throw new Error("Required columns missing in QualificationTypes_Definition.");
        
        let rowIndex = -1;
        for (let i = 1; i < data.length; i++) {
            if (data[i][idCol] === payload.QualificationTypeID) {
                rowIndex = i + 1; break;
            }
        }
        if (rowIndex === -1) throw new Error(`QualificationType ID ${payload.QualificationTypeID} not found.`);
        
        if (payload.QualificationName !== undefined) {
            if (payload.QualificationName.toLowerCase() !== data[rowIndex-1][nameCol].toLowerCase()) {
                 const existingQuals = getAllQualificationTypes();
                if (existingQuals.some(q => q.QualificationTypeID !== payload.QualificationTypeID && q.QualificationName.toLowerCase() === payload.QualificationName.toLowerCase())) {
                    throw new Error(`A qualification type with the name "${payload.QualificationName}" already exists.`);
                }
            }
            sheet.getRange(rowIndex, nameCol + 1).setValue(payload.QualificationName);
        }
        if (payload.Description !== undefined) {
            sheet.getRange(rowIndex, descCol + 1).setValue(payload.Description);
        }
        logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Updated QualificationType: ${payload.QualificationTypeID}`);
        return { success: true, qualificationType: payload };
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error updating ${payload.QualificationTypeID}: ${e.message}`);
        throw e;
    }
}

function deleteQualificationType(qualificationTypeId) {
    if (!qualificationTypeId) throw new Error("QualificationType ID is required for deletion.");
    const SCRIPT_NAME = "deleteQualificationType";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("QualificationTypes_Definition");
        if (!sheet) throw new Error("QualificationTypes_Definition sheet not found.");

        const iqLinkSheet = musicianDB.getSheetByName("InstrumentQualification_Link");
        if (iqLinkSheet) {
            const iqData = iqLinkSheet.getDataRange().getValues();
            const iqHeaders = iqData.length > 0 ? iqData[0].map(h => String(h).trim()) : [];
            const iqQualTypeIdCol = iqHeaders.indexOf("QualificationTypeID");
            if (iqQualTypeIdCol !== -1) {
                for (let i=1; i < iqData.length; i++) {
                    if (iqData[i][iqQualTypeIdCol] === qualificationTypeId) {
                        throw new Error(`Cannot delete QualificationType ${qualificationTypeId}. It is used in InstrumentQualification_Link.`);
                    }
                }
            }
        }

        const data = sheet.getDataRange().getValues();
        const headers = data[0].map(h => String(h).trim());
        const idCol = headers.indexOf("QualificationTypeID");
        if (idCol === -1) throw new Error("QualificationTypeID column not found.");
        
        const rowsToKeep = [headers];
        let deleted = false;
        for(let i=1; i < data.length; i++){
            if(data[i][idCol] === qualificationTypeId){ deleted = true; } 
            else { rowsToKeep.push(data[i]); }
        }

        if (deleted) {
            sheet.clearContents();
            if (rowsToKeep.length > 0) sheet.getRange(1,1,rowsToKeep.length, headers.length).setValues(rowsToKeep);
            else if (headers.length > 0) sheet.getRange(1,1,1,headers.length).setValues([headers]);
            logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Deleted QualificationType: ${qualificationTypeId}.`);
            return { success: true, deletedQualificationTypeID: qualificationTypeId };
        } else {
            throw new Error(`QualificationType ID ${qualificationTypeId} not found for deletion.`);
        }
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error deleting ${qualificationTypeId}: ${e.message}`);
        throw e;
    }
}

// --- Ranking Lists Definitions ---
function getRankingListsAdminList() {
    try {
        const rlDefs = getAllRankingListDefinitions(); // Uses Block 2 helper
        if (!rlDefs) return { error: "Could not retrieve ranking list definitions or sheet is empty."};
        
        // Enrich with InstrumentQualificationName for better display
        const iqLinks = getMusicianDbSheetData("InstrumentQualification_Link");
        let iqMap = {};
        if (iqLinks && iqLinks.length > 1) {
            const iqHeaders = iqLinks[0].map(h=>String(h).trim());
            const iqIdCol = iqHeaders.indexOf("InstrumentQualificationID");
            const iqNameCol = iqHeaders.indexOf("SpecificRoleNameForInstrument");
            if (iqIdCol !== -1 && iqNameCol !== -1) {
                for(let i=1; i < iqLinks.length; i++) {
                    if(iqLinks[i][iqIdCol]) iqMap[iqLinks[i][iqIdCol]] = iqLinks[i][iqNameCol];
                }
            }
        }
        return rlDefs.map(rl => ({
            ...rl,
            AppliesTo_InstrumentQualificationName: iqMap[rl.AppliesTo_InstrumentQualificationID] || rl.AppliesTo_InstrumentQualificationID
        }));

    } catch (e) {
        logEvent("ERROR", "getRankingListsAdminList", null, null, null, `Error: ${e.message}`);
        throw e;
    }
}

function getRankingListDetails(rankingListId) {
     if (!rankingListId) throw new Error("RankingList ID required.");
    try {
        const rlDefs = getAllRankingListDefinitions();
        if (!rlDefs) throw new Error("Could not retrieve ranking list definitions.");
        let rlDef = rlDefs.find(rl => rl.RankingListID === rankingListId);
        if (!rlDef) throw new Error(`RankingList with ID ${rankingListId} not found.`);

        const iqLinks = getMusicianDbSheetData("InstrumentQualification_Link");
        if (iqLinks && iqLinks.length > 1 && rlDef.AppliesTo_InstrumentQualificationID) {
            const iqHeaders = iqLinks[0].map(h=>String(h).trim());
            const iqIdCol = iqHeaders.indexOf("InstrumentQualificationID");
            const iqNameCol = iqHeaders.indexOf("SpecificRoleNameForInstrument");
            if (iqIdCol !== -1 && iqNameCol !== -1) {
                const iqLink = iqLinks.slice(1).find(link => link[iqIdCol] === rlDef.AppliesTo_InstrumentQualificationID);
                if (iqLink) rlDef.AppliesTo_InstrumentQualificationName = iqLink[iqNameCol];
            }
        }
        return rlDef;
    } catch (e) {
        logEvent("ERROR", "getRankingListDetails", null, null, null, `Error for ID ${rankingListId}: ${e.message}`);
        throw e;
    }
}

function addRankingList(payload) {
    const { RankingListName, AppliesTo_InstrumentQualificationID, Description, Status } = payload;
    if (!RankingListName || String(RankingListName).trim() === "" || !AppliesTo_InstrumentQualificationID) {
        throw new Error("RankingList Name and AppliesTo_InstrumentQualificationID are required.");
    }
    const SCRIPT_NAME = "addRankingList";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("RankingLists_Definition");
        if (!sheet) throw new Error("RankingLists_Definition sheet not found.");

        const existingRLs = getAllRankingListDefinitions();
        if(existingRLs && existingRLs.some(rl => rl.RankingListName.toLowerCase() === String(RankingListName).trim().toLowerCase() && rl.AppliesTo_InstrumentQualificationID === AppliesTo_InstrumentQualificationID)){
            throw new Error(`A ranking list with name "${RankingListName}" for the selected qualification already exists.`);
        }

        const newId = generateUniqueId("RL_");
        // Headers: RankingListID, RankingListName, AppliesTo_InstrumentQualificationID, Description, Status
        sheet.appendRow([newId, String(RankingListName).trim(), AppliesTo_InstrumentQualificationID, Description || "", Status || "Active"]); 
        logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Added RankingList: ${RankingListName} (ID: ${newId})`);
        return { RankingListID: newId, RankingListName: String(RankingListName).trim(), AppliesTo_InstrumentQualificationID, Description: Description || "", Status: Status || "Active" };
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error adding ${RankingListName}: ${e.message}`);
        throw e;
    }
}

function updateRankingList(payload) {
    if (!payload || !payload.RankingListID) throw new Error("RankingListID is required for update.");
    const SCRIPT_NAME = "updateRankingList";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("RankingLists_Definition");
        if (!sheet) throw new Error("RankingLists_Definition sheet not found.");

        const data = sheet.getDataRange().getValues();
        const headers = data[0].map(h => String(h).trim());
        const idCol = headers.indexOf("RankingListID");
        const nameCol = headers.indexOf("RankingListName");
        const appliesToCol = headers.indexOf("AppliesTo_InstrumentQualificationID");
        const descCol = headers.indexOf("Description");
        const statusCol = headers.indexOf("Status");
        if ([idCol,nameCol,appliesToCol,descCol,statusCol].includes(-1)) throw new Error("Required columns missing in RankingLists_Definition.");
        
        let rowIndex = -1;
        for (let i = 1; i < data.length; i++) {
            if (data[i][idCol] === payload.RankingListID) {
                rowIndex = i + 1; break;
            }
        }
        if (rowIndex === -1) throw new Error(`RankingList ID ${payload.RankingListID} not found.`);
        
        if (payload.RankingListName !== undefined) {
            if(payload.RankingListName.toLowerCase() !== data[rowIndex-1][nameCol].toLowerCase() || payload.AppliesTo_InstrumentQualificationID !== data[rowIndex-1][appliesToCol]){
                const existingRLs = getAllRankingListDefinitions();
                if(existingRLs.some(rl => rl.RankingListID !== payload.RankingListID && rl.RankingListName.toLowerCase() === payload.RankingListName.toLowerCase() && rl.AppliesTo_InstrumentQualificationID === payload.AppliesTo_InstrumentQualificationID)){
                    throw new Error(`Another ranking list with name "${payload.RankingListName}" for the selected qualification already exists.`);
                }
            }
            sheet.getRange(rowIndex, nameCol + 1).setValue(payload.RankingListName);
        }
        if (payload.AppliesTo_InstrumentQualificationID !== undefined) {
            sheet.getRange(rowIndex, appliesToCol + 1).setValue(payload.AppliesTo_InstrumentQualificationID);
        }
        if (payload.Description !== undefined) {
            sheet.getRange(rowIndex, descCol + 1).setValue(payload.Description);
        }
        if (payload.Status !== undefined) {
            sheet.getRange(rowIndex, statusCol + 1).setValue(payload.Status);
        }
        logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Updated RankingList: ${payload.RankingListID}`);
        return { success: true, rankingList: payload };
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error updating ${payload.RankingListID}: ${e.message}`);
        throw e;
    }
}

function deleteRankingList(rankingListId) {
    if (!rankingListId) throw new Error("RankingList ID is required for deletion.");
    const SCRIPT_NAME = "deleteRankingList";
    try {
        const musicianDB = getMusicianDatabaseSpreadsheet();
        if (!musicianDB) throw new Error("Cannot access Musician Database.");
        const sheet = musicianDB.getSheetByName("RankingLists_Definition");
        if (!sheet) throw new Error("RankingLists_Definition sheet not found.");

        const needsSheet = getSheet("Needs", OPERATIONS_SPREADSHEET_ID); // Needs sheet is in Operations DB
        if (needsSheet) {
            const needsData = needsSheet.getDataRange().getValues();
            const needsHeaders = needsData.length > 0 ? needsData[0].map(h=>String(h).trim()) : [];
            const needsRlIdCol = needsHeaders.indexOf("RankingListID");
            if (needsRlIdCol !== -1) {
                for(let i=1; i < needsData.length; i++) {
                    if(needsData[i][needsRlIdCol] === rankingListId) {
                        throw new Error(`Cannot delete RankingList ${rankingListId}. It is used in the Needs sheet.`);
                    }
                }
            }
        }

        const data = sheet.getDataRange().getValues();
        const headers = data[0].map(h => String(h).trim());
        const idCol = headers.indexOf("RankingListID");
        if (idCol === -1) throw new Error("RankingListID column not found.");
        
        const rowsToKeep = [headers];
        let deleted = false;
        for(let i=1; i < data.length; i++){
            if(data[i][idCol] === rankingListId){ deleted = true; } 
            else { rowsToKeep.push(data[i]); }
        }

        if (deleted) {
            sheet.clearContents();
            if (rowsToKeep.length > 0) sheet.getRange(1,1,rowsToKeep.length, headers.length).setValues(rowsToKeep);
            else if(headers.length > 0) sheet.getRange(1,1,1,headers.length).setValues([headers]);
            logEvent("SUCCESS", SCRIPT_NAME, null, null, null, `Deleted RankingList: ${rankingListId}.`);
            return { success: true, deletedRankingListID: rankingListId };
        } else {
            throw new Error(`RankingList ID ${rankingListId} not found for deletion.`);
        }
    } catch (e) {
        logEvent("ERROR", SCRIPT_NAME, null, null, null, `Error deleting ${rankingListId}: ${e.message}`);
        throw e;
    }
}


// ==========================================================================
//  SLUT PÅ BLOCK 8 - CRUD DEFINITIONS
// ==========================================================================
// ==========================================================================
//  BLOCK 9: SHEET TRIGGERS & SETUP SCRIPT (onEdit, initial setup)
// ==========================================================================
function onEdit(e) {
  const range = e.range;
  const sheet = range.getSheet();
  const sheetName = sheet.getName();
  const editedRow = range.getRow();
  const editedCol = range.getColumn();

  if (editedRow < 2 || range.getNumRows() > 1 || range.getNumColumns() > 1) {
    return;
  }

  if (sheetName === "ProjectInfo") {
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h=>String(h).trim());
    const projectStatusCol = headers.indexOf("ProjectStatus") + 1; 
    if (editedCol === projectStatusCol && projectStatusCol > 0) {
      const allowedStatuses = ["Planned", "Active", "Paused", "Completed", "Archived"];
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(allowedStatuses, true).setAllowInvalid(false).build();
      range.setDataValidation(rule);
    }
  } 
  else if (sheetName === "Needs") {
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h=>String(h).trim());
    const needStatusCol = headers.indexOf("NeedStatus") + 1;
    const dispatchTypeCol = headers.indexOf("DispatchType") + 1;
    const requiresAccCol = headers.indexOf("RequiresOwnAccomodation") + 1;

    if (editedCol === needStatusCol && needStatusCol > 0) {
      const allowedStatuses = ["Active", "Paused", "Filled", "AwaitingAdmin_FCFS"]; 
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(allowedStatuses, true).setAllowInvalid(false).build();
      range.setDataValidation(rule);
    } else if (editedCol === dispatchTypeCol && dispatchTypeCol > 0) {
      const allowedTypes = ["Sequential", "Parallel", "FCFS"];
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(allowedTypes, true).setAllowInvalid(false).build();
      range.setDataValidation(rule);
    } else if (editedCol === requiresAccCol && requiresAccCol > 0) {
      const allowedAcc = ["YES", "NO"]; 
      const rule = SpreadsheetApp.newDataValidation().requireValueInList(allowedAcc, true).setAllowInvalid(true).build();
      range.setDataValidation(rule);
    }
  }
}

function setupInitialSpreadsheetsAndSheets() {
  const ui = SpreadsheetApp.getUi();
  let operationsSpreadsheet;
  let musicianDbSpreadsheet;
  
  const localOperationsSpreadsheetName = getConfig("OperationsSpreadsheetName_Setup") || "Orchestra_Operations_Main"; 
  const localMusicianDbSpreadsheetName = getConfig("MusicianDbSpreadsheetName_Setup") || "Orchestra_MusicianDB_Main"; 


  try { 
    const filesOperations = DriveApp.getFilesByName(localOperationsSpreadsheetName);
    if (filesOperations.hasNext()) {
      operationsSpreadsheet = SpreadsheetApp.open(filesOperations.next());
    } else {
      operationsSpreadsheet = SpreadsheetApp.create(localOperationsSpreadsheetName);
    }
    if (SpreadsheetApp.getActiveSpreadsheet().getId() === OPERATIONS_SPREADSHEET_ID) {
        operationsSpreadsheet = SpreadsheetApp.getActiveSpreadsheet();
        Logger.log(`Using active spreadsheet as Operations SS: ${operationsSpreadsheet.getName()}`);
    } else if (operationsSpreadsheet.getId() !== OPERATIONS_SPREADSHEET_ID) {
        try {
            operationsSpreadsheet = SpreadsheetApp.openById(OPERATIONS_SPREADSHEET_ID);
            Logger.log(`Opened Operations SS by hardcoded ID: ${OPERATIONS_SPREADSHEET_ID}`);
        } catch (idError) {
            ui.alert("Setup Error", `The hardcoded OPERATIONS_SPREADSHEET_ID ('${OPERATIONS_SPREADSHEET_ID}') could not be opened. Please ensure it's correct and you have access. Error: ${idError.message}`);
            return;
        }
    }
     ui.alert(`Using Operations Spreadsheet: '${operationsSpreadsheet.getName()}' (ID: ${operationsSpreadsheet.getId()})`);

  } catch (e) {
    ui.alert(`Fel vid hantering av Operations Spreadsheet: ${e.message}`); return;
  }

  try { 
    const filesMusicianDb = DriveApp.getFilesByName(localMusicianDbSpreadsheetName);
    if (filesMusicianDb.hasNext()) {
      musicianDbSpreadsheet = SpreadsheetApp.open(filesMusicianDb.next());
    } else {
      musicianDbSpreadsheet = SpreadsheetApp.create(localMusicianDbSpreadsheetName);
    }
    ui.alert(`Använder/Skapade Musician DB: '${musicianDbSpreadsheet.getName()}' (ID: ${musicianDbSpreadsheet.getId()}). Detta ID ska finnas i Configuration-fliken.`);
  } catch (e) {
    ui.alert(`Fel vid hantering av Musician DB Spreadsheet: ${e.message}`); return;
  }

  const musicianDbIdActual = musicianDbSpreadsheet.getId();

  const operationsSheetsStructure = {
    "ProjectInfo": ["ProjectID", "ProjectName", "WeekNumber", "RehearsalSchedule", "ConcertSchedule", "ResponseDeadlineHours", "DriveFolderID", "ProjectStatus", "Notes", "LastModified", "CreatedDate"],
    "Needs": ["NeedID", "ProjectID", "InstrumentID", "InstrumentQualificationID", "NeededQuantity", "RankingListID", "DispatchType", "MaxParallelDispatches", "RequiresOwnAccomodation", "NeedStatus", "Notes", "AdminNotified_FilledTimestamp", "LastModified", "CreatedDate"], 
    "ResponseTracking": ["DispatchID", "NeedID", "ProjectID", "MusicianID", "MusicianEmail", "ResponseStatus", "SentTimestamp", "DeadlineTimestamp", "ResponseTimestamp", "ReminderSentTimestamp", "AcknowledgementSentTimestamp", "FormLink", "AdminNotified_MusicianResponse"], 
    "Configuration": ["Key", "Value"],
    "EventLog": ["Timestamp", "LogType", "FunctionName", "ProjectID", "NeedID", "MusicianID", "Message"],
    "Archive_ProjectInfo": ["ProjectID", "ProjectName", "WeekNumber", "RehearsalSchedule", "ConcertSchedule", "ResponseDeadlineHours", "DriveFolderID", "ProjectStatus", "Notes", "LastModified", "CreatedDate"],
    "Archive_Needs": ["NeedID", "ProjectID", "InstrumentID", "InstrumentQualificationID", "NeededQuantity", "RankingListID", "DispatchType", "MaxParallelDispatches", "RequiresOwnAccomodation", "NeedStatus", "Notes", "AdminNotified_FilledTimestamp", "LastModified", "CreatedDate"],
    "Archive_ResponseTracking": ["DispatchID", "NeedID", "ProjectID", "MusicianID", "MusicianEmail", "ResponseStatus", "SentTimestamp", "DeadlineTimestamp", "ResponseTimestamp", "ReminderSentTimestamp", "AcknowledgementSentTimestamp", "FormLink", "AdminNotified_MusicianResponse"]
  };

  const musicianDbSheetsStructure = {
    "Instruments_Definition": ["InstrumentID", "InstrumentName", "Notes"],
    "QualificationTypes_Definition": ["QualificationTypeID", "QualificationName", "Description"],
    "InstrumentQualification_Link": ["InstrumentQualificationID", "InstrumentID", "QualificationTypeID", "SpecificRoleNameForInstrument"],
    "Musicians_MasterList": ["MusicianID", "FirstName", "LastName", "Email", "Phone", "PrimaryInstrumentID", "SecondaryInstrumentIDs", "HasOwnAccomodation", "Notes", "Status", "LastModified", "CreatedDate"],
    "MusicianSpecificQualifications_Link": ["MusicianSpecificQualificationID", "MusicianID", "InstrumentQualificationID"],
    "RankingLists_Definition": ["RankingListID", "RankingListName", "AppliesTo_InstrumentQualificationID", "Description", "Status"],
    "Rankings_Data": ["RankingDataID", "RankingListID", "MusicianID", "RankOrder", "Notes"]
  };

  createSheetsAndHeaders(operationsSpreadsheet, operationsSheetsStructure);
  createSheetsAndHeaders(musicianDbSpreadsheet, musicianDbSheetsStructure);
  
  const configSheet = operationsSpreadsheet.getSheetByName("Configuration");
  if (configSheet) {
    const defaultConfigValues = [
      ["MusicianDatabaseID", musicianDbIdActual], 
      ["AdminEmail", "zanganehbrusk@gmail.com"], 
      ["SystemPaused", "NO"], ["ReminderPercentage", "50"],
      ["NotifyAdmin_OnMusicianResponse_Yes", "YES"], ["NotifyAdmin_OnMusicianResponse_No", "NO"],
      ["NotifyAdmin_OnNeedFilled", "YES"],
      ["FCFS_DispatchMultiplier", "3"], 
      ["TriggerInterval_InitialRequests", "60"], ["TriggerInterval_Reminders", "15"],
      ["TriggerInterval_Deadlines", "15"], ["TriggerInterval_Completion", "60"],
      ["GoogleFormBaseURL", "YOUR_GOOGLE_FORM_URL_HERE/viewform"],
      ["FormEntryID_DispatchID", "entry.YOUR_DISPATCH_ID_FIELD_HERE"],
      ["FormEntryID_ProjectID", "entry.YOUR_PROJECT_ID_FIELD_HERE"],
      ["FormEntryID_NeedID", "entry.YOUR_NEED_ID_FIELD_HERE"],
      ["FormEntryID_Email", "entry.YOUR_EMAIL_FIELD_HERE"],
      ["FormQuestion_DispatchID_FieldName", "DispatchID (DO NOT EDIT)"], 
      ["FormQuestion_Response", "Svar"], 
      ["FormQuestion_ProjectID_FieldName", "ProjectID (Dummy)"], 
      ["FormQuestion_NeedID_FieldName", "NeedID (Dummy)"], 
      ["FormQuestion_Email_FieldName", "Email (Dummy)"], 
      ["MailTemplate_Request", "<h1>Förfrågan om spelning: {{ProjectName}}</h1><p>Hej {{MusicianFirstName}}, du har fått en förfrågan för rollen som {{Instrument}} ({{Qualification}}) i projekt {{ProjectName}} (Vecka {{WeekNumber}}).</p><p>Repetitioner: {{RehearsalSchedule}}</p><p>Konsert: {{ConcertSchedule}}</p><p>Vänligen svara senast {{DeadlineTimestamp}} via denna länk: <a href='{{FormLink}}'>Svara här</a></p><p>Med vänlig hälsning,<br>Orkesterledningen</p>"],
      ["MailTemplate_Reminder", "<h1>Påminnelse: Förfrågan {{ProjectName}}</h1><p>Hej {{MusicianFirstName}}, detta är en påminnelse angående förfrågan för {{Instrument}} ({{Qualification}}) i projekt {{ProjectName}}.</p><p>Sista svarsdag är {{DeadlineTimestamp}}.</p><p>Svara här: <a href='{{FormLink}}'>Svara här</a></p><p>Mvh,<br>Orkesterledningen</p>"],
      ["MailTemplate_Acknowledgement_Yes", "<h1>Tack för ditt JA till {{ProjectName}}!</h1><p>Hej {{MusicianFirstName}}, tack för att du tackat ja till rollen som {{Instrument}} ({{Qualification}}) i projekt {{ProjectName}}. Vi återkommer med mer information!</p><p>Mvh,<br>Orkesterledningen</p>"],
      ["MailTemplate_Acknowledgement_AlreadyFilled", "<h1>Platsen tyvärr fylld för {{ProjectName}}</h1><p>Hej {{MusicianFirstName}}, tack för ditt intresse för projekt {{ProjectName}} ({{Instrument}} - {{Qualification}}). Tyvärr hann platsen/platserna bli fyllda innan ditt svar registrerades. Vi hoppas på återseende i framtida projekt!</p><p>Mvh,<br>Orkesterledningen</p>"],
      ["MailTemplate_Admin_ProjectCompleted", "<h1>Projekt Slutfört: {{ProjectName}} ({{ProjectID}})</h1><p>Projektet {{ProjectName}} har markerats som slutfört den {{CompletionDate}}.</p><div>{{{ConfirmedMusiciansList}}}</div><p>Mvh,<br>Systemet</p>"],
      ["MailTemplate_Admin_FCFS_Batch_Incomplete", "<h1>FCFS Batch Ofullständig: {{ProjectName}} ({{ProjectID}})</h1><p>Behovet för {{Instrument}} ({{Qualification}}) i projekt {{ProjectName}} (NeedID: {{NeedID}}) är ännu inte fyllt efter att en FCFS-batch har bearbetats.</p><p>Behövs: {{NeededQuantity}}, Bekräftade: {{ConfirmedCount}}.</p><p>Manuell åtgärd kan behövas.</p><p>Mvh,<br>Systemet</p>"],
      ["MailTemplate_Admin_Response_On_Paused_Item", "<h1>Svar på Pausat Objekt: {{ProjectName}}</h1><p>Musiker {{MusicianName}} svarade {{Response}} på ett pausat behov ({{Instrument}} - {{Qualification}}) för projekt {{ProjectName}}.</p><p>Mvh,<br>Systemet</p>"],
      ["MailTemplate_Admin_MusicianResponded", "<h1>Musiker Svarade: {{ProjectName}}</h1><p>Musiker {{MusicianName}} svarade <strong>{{Response}}</strong> för {{Instrument}} ({{Qualification}}) i projekt {{ProjectName}}.</p><p>Mvh,<br>Systemet</p>"],
      ["MailTemplate_Admin_NeedFilled", "<h1>Behov Fyllt: {{ProjectName}}</h1><p>Behovet för {{Instrument}} ({{Qualification}}) i projekt {{ProjectName}} är nu fyllt.</p><p>Mvh,<br>Systemet</p>"]
    ];
    
    const existingConfigData = configSheet.getDataRange().getValues();
    const existingConfigMap = new Map();
    existingConfigData.slice(1).forEach(row => { if(row[0]) existingConfigMap.set(row[0], row[1]); });

    defaultConfigValues.forEach(pair => existingConfigMap.set(pair[0], pair[1])); 

    const newConfigArray = [[configSheet.getRange(1,1).getValue(), configSheet.getRange(1,2).getValue()]]; 
    existingConfigMap.forEach((value, key) => newConfigArray.push([key,value]));
    
    configSheet.clearContents(); 
    configSheet.getRange(1,1,newConfigArray.length, 2).setValues(newConfigArray); 
    Logger.log("Configuration-fliken har populerats/uppdaterats.");
  }

  ui.alert("Setup är klar! Kontrollera Logger (Visa > Loggar). Viktigt: Uppdatera 'GoogleFormBaseURL' och FormEntryID-värdena i Configuration-fliken i din Operations Spreadsheet för att matcha ditt Google Form!");
}

function createSheetsAndHeaders(spreadsheet, sheetStructure) {
  for (const sheetName in sheetStructure) {
    let sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet) {
      sheet = spreadsheet.insertSheet(sheetName);
    } 
    if (sheet.getLastRow() === 0 || sheet.getRange(1, 1, 1, sheet.getMaxColumns()).getValues()[0].every(cell => cell === "")) {
      sheet.getRange(1, 1, 1, sheetStructure[sheetName].length).setValues([sheetStructure[sheetName]]);
      sheet.setFrozenRows(1); 
    }
  }
  const defaultSheet = spreadsheet.getSheetByName("Sheet1") || spreadsheet.getSheetByName("Blad1"); 
  if (defaultSheet && spreadsheet.getSheets().length > 1) {
    try { spreadsheet.deleteSheet(defaultSheet); } catch (e) { /* ignore if only sheet */ }
  }
}
// ------------- SLUT PÅ SCRIPT FÖR SETUP -------------



// THIS doGet FUNCTION IS NOW FOR SERVING THE INTERNAL HTML UI
// IN Code.gs
function doGet(e) {
  Logger.log("doGet called to serve internal HTML UI (single file)");
  let htmlOutput = HtmlService.createHtmlOutputFromFile('Index'); // Assuming your single HTML file is named Index.html
  htmlOutput.setTitle("StageSub Administration (Internal)")
            .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  return htmlOutput;
}


function doPost(e) {
  let action = "unknown";
  let responsePayload; 
  try {
    // ... (your existing doPost logic) ...
    // This will likely NOT be called if your internal HTML uses google.script.run for everything
    // However, if you have external systems POSTing to this URL, keep it.
    // For now, I'll keep the structure but you might find you don't need it.
    if (!e || !e.postData || !e.postData.contents) throw new Error("No POST data.");
    let requestData;
    try { requestData = JSON.parse(e.postData.contents); } 
    catch (parseError) { throw new Error(`Invalid POST data format: ${parseError.message}`);}
    
    action = requestData.action;
    let payload = requestData.payload;
    if (!action) throw new Error("No action specified in POST data.");

    let resultData; 
    switch (String(action).trim()) {
      case 'createNewProject': resultData = createNewProject(payload); break;
      case 'updateExistingProject': resultData = updateExistingProject(payload); break;
      case 'createNewNeed': resultData = createNewNeed(payload); break;
      case 'updateExistingNeed': resultData = updateExistingNeed(payload); break;
      case 'deleteNeedFromSheet': 
        if (!payload || !payload.needID) throw new Error("needID missing in payload for delete.");
        resultData = deleteNeedFromSheet(String(payload.needID).trim()); break;
      case 'archiveProject': 
        if (!payload || !payload.projectID) throw new Error("projectID missing in payload for archive.");
        resultData = archiveProject(String(payload.projectID).trim()); break; 
      case 'createNewMusician': resultData = createNewMusician(payload); break;
      case 'updateExistingMusician': resultData = updateExistingMusician(payload); break;
      case 'addInstrument': 
        if(!payload || !payload.instrumentName) throw new Error("instrumentName missing in payload for addInstrument.");
        resultData = addInstrument(payload.instrumentName); break;
      case 'updateInstrument': resultData = updateInstrument(payload); break;
      case 'deleteInstrument': 
        if(!payload || !payload.instrumentID) throw new Error("instrumentID missing in payload for deleteInstrument.");
        resultData = deleteInstrument(payload.instrumentID); break;
      case 'addQualificationType': resultData = addQualificationType(payload); break;
      case 'updateQualificationType': resultData = updateQualificationType(payload); break;
      case 'deleteQualificationType':
        if(!payload || !payload.qualificationTypeId) throw new Error("qualificationTypeId missing for deleteQualificationType.");
        resultData = deleteQualificationType(payload.qualificationTypeId); break;
      case 'addRankingList': resultData = addRankingList(payload); break;
      case 'updateRankingList': resultData = updateRankingList(payload); break;
      case 'deleteRankingList':
        if(!payload || !payload.rankingListId) throw new Error("rankingListId missing for deleteRankingList.");
        resultData = deleteRankingList(payload.rankingListId); break;
      default:
        throw new Error(`Unknown POST action: ${action}`);
    }
    responsePayload = { success: true, data: resultData };

  } catch (error) {
    Logger.log(`Error in doPost (Action: ${action}): ${error.toString()} \nStack: ${error.stack}`);
    responsePayload = { success: false, error: error.message, details: `Server-side POST error. Action: ${action}.` };
  }
  
  const finalResponse = ContentService.createTextOutput(JSON.stringify(responsePayload)).setMimeType(ContentService.MimeType.JSON);
  finalResponse.setHeader('Access-Control-Allow-Origin', '*');
  finalResponse.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS'); 
  finalResponse.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization'); 
  return finalResponse;
}

function doOptions(e) { 
  const response = ContentService.createTextOutput();
  response.setMimeType(ContentService.MimeType.TEXT); 
  response.setContent("ok"); 
  response.setHeader('Access-Control-Allow-Origin', '*');
  response.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE'); 
  response.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  return response;
}

